{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "21ea3123-3174-3d79-b784-74a27a5252e9",
              "name": "\"Postgresql Server Vulnerability to MITN Attacks due to Disabled TLS and Sequelize's Non-Enforcement of TLS\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability arises when a PostgreSQL server is configured to accept connections without Transport Layer Security (TLS), and Sequelize, a promise-based Node.js Object-Relational Mapping (ORM) for SQL databases, does not enforce TLS. This can expose the server to Man-In-The-Middle (MITM) attacks where an attacker can intercept and possibly alter the communication between the client and the server.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Enable and enforce TLS on your PostgreSQL server. This will encrypt the communication between the client and the server, making it difficult for an attacker to read or modify the data.\n\n2. Configure Sequelize to use SSL/TLS for database connections. This will ensure that Sequelize only communicates with the server over a secure connection.\n\n## Source Code Fix Recommendation\n\nYou can enforce SSL/TLS in Sequelize by adding the `dialectOptions` property to the configuration object:\n\n```javascript\nmodule.exports = {\n  username: process.env.MYSQL_USER,\n  password: process.env.MYSQL_PASSWORD,\n  database: process.env.MYSQL_DATABASE,\n  host: process.env.MYSQL_HOST || 'mysql-db',\n  port: process.env.MYSQL_PORT || 3306,\n  dialect: 'mysql',\n  dialectOptions: {\n    ssl: {\n      require: true,\n      rejectUnauthorized: false\n    }\n  }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `dotenv`: To load environment variables from a `.env` file.\n- `sequelize`: To interact with the MySQL database.\n\n## References\n\n- [OWASP Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-319",
                    "url": "https://cwe.mitre.org/data/definitions/319.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-319"
                ]
              }
            },
            {
              "id": "fd7234c9-f60f-32b7-86c2-9d3be0e45876",
              "name": "\"XML Parsing Library Found: Disable External Entity Resolution to Avoid XXE Attacks\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nXML External Entity (XXE) attacks occur when an XML parser processes XML input that contains a reference to an external entity. This can lead to the disclosure of confidential data, denial of service, server side request forgery, port scanning from the perspective of the machine where the parser is located, and other system impacts.\n\nIn JavaScript, if you're using the `libxmljs` library to parse XML data, you might be vulnerable to XXE attacks if you don't disable the resolution of external entities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should disable the resolution of external entities in the XML parser. This can be done by setting the `noent` option to `false` when parsing XML data.\n\n## Source Code Fix Recommendation\n\nHere's how you can disable the resolution of external entities in `libxmljs`:\n\n```javascript\nvar libxmljs = require(\"libxmljs\");\n\nvar xml = \"...\"; // your XML data\n\nvar xmlDoc = libxmljs.parseXmlString(xml, {noent: false});\n```\n\nIn this code, the `noent` option is set to `false`, which disables the resolution of external entities.\n\n## Library Dependencies\n\nThe only library dependency required by the code example is `libxmljs`.\n\n## References\n\n- [OWASP XXE Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n- [CWE-611: Improper Restriction of XML External Entity Reference ('XXE')](https://cwe.mitre.org/data/definitions/611.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-611",
                    "url": "https://cwe.mitre.org/data/definitions/611.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-611"
                ]
              }
            },
            {
              "id": "1b1c4619-f040-3f90-9111-3ca724783e40",
              "name": "\"Potential XSS Vulnerability from User-Controlled Data in HTML String\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA potential Cross-Site Scripting (XSS) vulnerability from user-controlled data in HTML string exists when an application includes untrusted data in a new HTML string used in a JavaScript context. This vulnerability can occur when user input is included in a string that is used in a dynamic SQL query. An attacker can inject malicious scripts into the application, which are then executed by the victim's browser.\n\nIn the provided code snippet, the application is vulnerable to SQL Injection, which could potentially lead to XSS if the data is later used in an HTML context.\n\n```javascript\nvar query = \"SELECT name,id FROM Users WHERE login='\" + req.body.login + \"'\";\n```\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Use parameterized queries or prepared statements instead of string concatenation to prevent SQL Injection.\n2. Always validate and sanitize user input to ensure it does not contain malicious scripts.\n3. Use Content Security Policy (CSP) to reduce the risk of XSS attacks.\n4. Use HTTPOnly cookies to prevent access from JavaScript.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix using parameterized queries:\n\n```javascript\nvar sql = \"SELECT name,id FROM Users WHERE login= ?\";\nvar inserts = [req.body.login];\nsql = mysql.format(sql, inserts);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Express.js: For handling HTTP requests and responses.\n- MySQL: For interacting with a MySQL database.\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  },
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79",
                  "CWE-89"
                ]
              }
            },
            {
              "id": "c9476c0e-2a36-30ee-9141-e9d85491bb1a",
              "name": "\"Detected Vulnerability in node-serialize Library Allowing Arbitrary Code Execution\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `node-serialize` library in JavaScript is vulnerable to arbitrary code execution. This vulnerability allows an attacker to execute arbitrary code on the server by providing a serialized object with a malicious payload. This happens because the `node-serialize` library uses the `eval()` function to deserialize objects, which can execute any JavaScript code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using the `node-serialize` library for deserializing untrusted data. Instead, use a safe alternative like `JSON.parse()`. \n\nAlso, always validate and sanitize user input to prevent code injection attacks. \n\n## Source Code Fix Recommendation\n\nReplace the `node-serialize` library with a safer alternative. Here is an example of how to do it:\n\n```javascript\n// Instead of this:\nvar serialize = require(\"node-serialize\");\n\n// Use this:\nvar serialize = JSON.parse;\n```\n\n## Library Dependencies\n\nThe code example requires the `node-serialize` library to execute properly.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A8-Insecure Deserialization](https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-502: Deserialization of Untrusted Data](https://cwe.mitre.org/data/definitions/502.html)\n- [CWE-94: Improper Control of Generation of Code ('Code Injection')](https://cwe.mitre.org/data/definitions/94.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                  },
                  {
                    "id": "CWE-94",
                    "url": "https://cwe.mitre.org/data/definitions/94.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-502",
                  "CWE-94"
                ]
              }
            },
            {
              "id": "f9220330-3239-30f0-bb86-58261d761080",
              "name": "\"Libxml library's `noent` attribute set to `true` can lead to XXE vulnerabilities; recommended to set `noent` to `false` for protection.\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `noent` attribute in the `libxmljs` library in JavaScript is used to substitute entities in an XML document. When this attribute is set to `true`, it can lead to XML External Entity (XXE) vulnerabilities. XXE vulnerabilities occur when an application processing XML input allows the inclusion of dynamic external entities. This can lead to the disclosure of confidential data, denial of service, server-side request forgery, port scanning from the perspective of the machine where the parser is located, and other system impacts.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to disable the `noent` attribute by setting it to `false`. This will prevent the parser from substituting entities with their values, thus preventing XXE attacks.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the vulnerability in the provided code:\n\n```javascript\nvar products = libxmljs.parseXmlString(req.files.products.data.toString('utf8'), {noent:false,noblanks:true})\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- `libxmljs`: A library for parsing and serializing XML documents.\n\n## References\n\n- [OWASP XXE Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n- [CWE-611: Improper Restriction of XML External Entity Reference ('XXE')](https://cwe.mitre.org/data/definitions/611.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-611",
                    "url": "https://cwe.mitre.org/data/definitions/611.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-611"
                ]
              }
            },
            {
              "id": "bab5710e-f80a-3d06-a815-795f80c5ba2a",
              "name": "\"Undetected CSRF Middleware in Your Express Application\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Request Forgery (CSRF) is a type of attack that occurs when a malicious web site, email, blog, instant message, or program causes a user's web browser to perform an unwanted action on a trusted site for which the user is currently authenticated. If the application does not have CSRF protection middleware, it is vulnerable to this type of attack.\n\nIn the context of Express.js, if the application does not use any CSRF protection middleware, it is vulnerable to CSRF attacks. This is because Express.js does not include CSRF protection in its core, and it must be added manually.\n\n## Mitigation Advice\n\nTo mitigate CSRF attacks, you should use CSRF protection middleware. There are several CSRF protection middleware available for Express.js, such as `csurf`. This middleware creates a CSRF token that must be sent with requests that change server state. Without the token, the server will not accept the request.\n\n## Source Code Fix Recommendation\n\nFirst, install the `csurf` middleware:\n\n```bash\nnpm install csurf\n```\n\nThen, use it in your Express.js application:\n\n```javascript\nvar express = require('express')\nvar cookieParser = require('cookie-parser')\nvar csrf = require('csurf')\n\nvar csrfProtection = csrf({ cookie: true })\nvar app = express()\n\napp.use(cookieParser())\n\napp.get('/form', csrfProtection, function (req, res) {\n  // pass the csrfToken to the view\n  res.render('send', { csrfToken: req.csrfToken() })\n})\n\napp.post('/process', csrfProtection, function (req, res) {\n  // process the request\n})\n```\n\nIn this example, the `csrfProtection` middleware is used to protect the routes. The CSRF token is passed to the view when rendering the form, and it must be included in the form submission.\n\n## Library Dependencies\n\n- express\n- cookie-parser\n- csurf\n\n## References\n\n- [OWASP CSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n- [CWE-352: Cross-Site Request Forgery (CSRF)](https://cwe.mitre.org/data/definitions/352.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-352",
                    "url": "https://cwe.mitre.org/data/definitions/352.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-352"
                ]
              }
            },
            {
              "id": "055908f0-60ec-34e2-99d7-df61704e3569",
              "name": "Potential Path Traversal Vulnerability Detected in `path.join` or `path.resolve` Function Due to Unsanitized User Input",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA potential Path Traversal vulnerability has been detected in the `path.join` or `path.resolve` function due to unsanitized user input. This vulnerability, also known as directory traversal, is a type of application security vulnerability which allows attackers to read arbitrary files on the application's host machine, that are outside of the intended directory. In JavaScript, this vulnerability can occur when the application uses user input to construct a path to a file or directory without properly sanitizing it.\n\nIn the provided code snippet, the `sequelize.import` function is using `path.join` to construct a path to a file. If the `file` variable is user-controlled and not properly sanitized, an attacker could manipulate the path to access files outside of the intended directory.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to validate and sanitize user input. Avoid using user input to form file paths where possible. If it is necessary, ensure that the input is strictly validated. This can include checking for path traversal sequences (../ or ..\\), null bytes (%00), or newlines (%0A or %0D).\n\n## Source Code Fix Recommendation\n\n```javascript\nvar path = require('path');\nvar file = getUserInput();\n\n// Validate user input\nif (!isValidInput(file)) {\n    throw new Error('Invalid input');\n}\n\n// Sanitize user input\nfile = sanitizeInput(file);\n\nvar model = sequelize.import(path.join(__dirname, file));\n```\n\nIn this example, `isValidInput` and `sanitizeInput` are placeholder functions that you would need to implement. `isValidInput` should return a boolean indicating whether the input is valid, and `sanitizeInput` should return a sanitized version of the input.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `sequelize`: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n- `path`: A core Node.js module for handling and transforming file paths.\n\n## References\n\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)\n- [CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')](https://cwe.mitre.org/data/definitions/22.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-22"
                ]
              }
            },
            {
              "id": "0960e248-84d3-3502-bcd0-541e59f5ebba",
              "name": "\"SQL Injection Risk from Untrusted Input Concatenation: Use Data Replacement or Binding\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe code snippet provided is vulnerable to SQL Injection due to the concatenation of untrusted input directly into a SQL query. This vulnerability allows an attacker to manipulate the SQL query by injecting arbitrary SQL code through the `req.body.login` input.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use parameterized queries or prepared statements. These techniques ensure that user inputs are always treated as literal values, not part of the SQL command. This way, even if an attacker attempts to inject SQL code, it will not be executed as part of the command.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using Sequelize's built-in protection against SQL Injection:\n\n```javascript\nvar query = \"SELECT name,id FROM Users WHERE login= :login\";\ndb.sequelize.query(query, {\n\tmodel: db.User,\n\treplacements: { login: req.body.login }\n}).then(user => {\n\t// rest of the code\n}).catch(err => {\n\t// error handling\n});\n```\n\nIn this version, `:login` is a placeholder that Sequelize will replace with the value of `req.body.login`, properly escaped to prevent SQL Injection.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n- Express.js: A web application framework for Node.js, used for routing and handling HTTP requests and responses.\n\n## References\n\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-89"
                ]
              }
            },
            {
              "id": "31813b77-cfad-3bb8-8371-b438a70a3e1b",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a Promise is rejected, but this rejection is not caught or handled with a `.catch()` method. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information in error messages.\n\nIn the provided code, the vulnerability lies in the `.catch()` block. The error `err` is caught, but nothing is done with it. This means that if the Promise is rejected, the error will not be handled properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle Promise rejections. This can be done by adding a `.catch()` block to your Promise chain, and then handling the error appropriately within this block. This might involve logging the error, returning a default value, or throwing an error to be caught higher up in your application.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.sequelize.query(query, {\n\tmodel: db.User\n}).then(user => {\n\tif (user.length) {\n\t\tvar output = {\n\t\t\tuser: {\n\t\t\t\tname: user[0].name,\n\t\t\t\tid: user[0].id\n\t\t\t}\n\t\t}\n\t\tres.render('app/usersearch', {\n\t\t\toutput: output\n\t\t})\n\t} else {\n\t\treq.flash('warning', 'User not found')\n\t\tres.render('app/usersearch', {\n\t\t\toutput: null\n\t\t})\n\t}\n}).catch(err => {\n\tconsole.error(err);\n\treq.flash('error', 'An error occurred while searching for the user');\n\tres.render('app/usersearch', {\n\t\toutput: null\n\t});\n});\n```\n\nIn this fixed version, the `.catch()` block logs the error and then flashes a generic error message to the user. It also renders the `usersearch` view with no output.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- Sequelize (for the `db.sequelize.query()` method)\n- Express (for the `res.render()` method)\n- Connect-flash (for the `req.flash()` method)\n\n## References\n\n- [OWASP Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "a46d83fc-ded8-3469-8316-e0528591d6d3",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when user-supplied data is not properly sanitized or escaped before being included in an EJS template. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts into web pages viewed by other users. These scripts can steal sensitive information, perform actions on behalf of the user, or exploit other vulnerabilities in the user's browser.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always escape user-supplied data before including it in an EJS template. This can be done using the `<%= %>` syntax in EJS, which automatically escapes HTML characters. Additionally, it is a good practice to validate and sanitize user input on the server side before using it in any context.\n\n## Source Code Fix Recommendation\n\nThe vulnerable code:\n\n```javascript\nListing products with <strong>search query: </strong> <%- output.searchTerm %>\n```\n\nThe fixed code:\n\n```javascript\nListing products with <strong>search query: </strong> <%= output.searchTerm %>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## References\n\n- [OWASP XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "d20ba9e2-94ee-370c-9227-db01ee13e9a0",
              "name": "Detected Hard-Coded Credential Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nDetected Hard-Coded Credential Vulnerability refers to the insecure practice of embedding plaintext credentials directly within the source code. This vulnerability can lead to unauthorized access if the source code is ever exposed, as the credentials are easily readable. In JavaScript, this vulnerability can occur when sensitive data like API keys, database credentials, or in this case, a secret key for session management, are hard-coded into the application.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, sensitive data should never be hard-coded directly into the source code. Instead, use environment variables to store this data. Environment variables are a type of dynamic-named value that can affect the way running processes behave on a computer. They are part of the environment in which a process runs.\n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the secret directly into the code, you should store it in an environment variable. Here's how you can do it:\n\n```javascript\nconst express = require('express');\nconst session = require('express-session');\n\nconst app = express();\n\napp.use(session({\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: true\n}));\n\n// rest of your code\n```\n\nIn this code, `process.env.SESSION_SECRET` is used to access the `SESSION_SECRET` environment variable. You can set this variable in your server's environment, or if you're using a platform like Heroku, in the settings for your application.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- express\n- express-session\n\n## References\n\n- [OWASP Top 10-2017 A2-Broken Authentication](https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication)\n- [OWASP Top 10-2017 A3-Sensitive Data Exposure](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-798",
                    "url": "https://cwe.mitre.org/data/definitions/798.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-798"
                ]
              }
            },
            {
              "id": "af01a7ee-caac-33b0-a917-bfcfb3bce866",
              "name": "Unset 'secure' in default session middleware settings vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `secure` flag in the session middleware settings of an Express.js application is used to specify whether cookies should be sent over secure connections only. When `secure` is set to `false`, cookies can be sent over unencrypted connections, which makes them vulnerable to interception and manipulation by attackers. This is a violation of the OWASP Secure Coding Practices, which recommend that all cookies should be sent over secure connections only.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should set the `secure` flag to `true` in your session middleware settings. This will ensure that cookies are sent over secure connections only. However, you should be aware that this will prevent your application from sending cookies over unencrypted connections, which may impact functionality if your application is not set up to use HTTPS.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the vulnerability in your source code:\n\n```javascript\napp.use(session({\n  secret: 'keyboard cat',\n  resave: true,\n  saveUninitialized: true,\n  cookie: { secure: true }\n}))\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- express\n- express-session\n\n## References\n\n- [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-319",
                    "url": "https://cwe.mitre.org/data/definitions/319.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-319"
                ]
              }
            },
            {
              "id": "84b854a1-f34b-311e-ba56-c80d48d54711",
              "name": "Preventing SQL Injection Vulnerability through Prepared Statements, Parameterized Queries, and ORM Frameworks",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nSQL Injection is a code injection technique that attackers can use to exploit vulnerabilities in a web application's database layer. This happens when the application's controls allow unfiltered user-supplied input into SQL queries. In JavaScript, this vulnerability can be exploited when using SQL-based databases such as MySQL, PostgreSQL, SQLite, etc.\n\nThe vulnerability sink in the provided code snippet is the `query` variable that is passed directly to the `db.sequelize.query()` function. If the `query` variable is constructed using user-supplied input, it can lead to SQL Injection attacks.\n\n## Mitigation Advice\n\nTo prevent SQL Injection vulnerabilities, it is recommended to use Prepared Statements, Parameterized Queries, or ORM (Object-Relational Mapping) Frameworks. These techniques ensure that user-supplied input is always treated as literal data, not part of the SQL command.\n\n- **Prepared Statements**: These are SQL statements that are sent to and parsed by the database server separately from any parameters. This way, it is impossible for an attacker to inject malicious SQL.\n\n- **Parameterized Queries**: These are database queries in which placeholders are used for parameters and the parameter values are supplied at execution time.\n\n- **ORM Frameworks**: These are programming techniques for converting data between incompatible type systems using object-oriented programming languages. They create a \"virtual object database\" that can be used from within the programming language.\n\n## Source Code Fix Recommendation\n\n```javascript\nlet userId = getUserInput();\n\n// Use sequelize's built-in support for parameterized queries\ndb.sequelize.query('SELECT * FROM users WHERE id = :userId', \n  { replacements: { userId: userId }, type: db.sequelize.QueryTypes.SELECT }\n).then(users => {\n  console.log(users)\n})\n```\n\n## Library Dependencies\n\n- sequelize\n\n## References\n\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [OWASP Sequelize](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#sequelize)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-89"
                ]
              }
            },
            {
              "id": "90408b14-a210-379b-a93e-9fa7a1965540",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when unescaped external data is used in an EJS template. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts into web pages viewed by other users. These scripts can steal sensitive information, manipulate web content, or perform actions on behalf of the user without their consent.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always escape external data before using it in your templates. This can be done using the `<%- %>` syntax in EJS, which escapes HTML entities. Never trust user input or any data that comes from an external source.\n\n## Source Code Fix Recommendation\n\nIn your specific code example, the `id` property of the `products` array is being output without being escaped. This can be fixed by using the `<%- %>` syntax to escape the `id`:\n\n```javascript\n<td><%- output.products[i].id %></td>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- EJS\n\n## OWASP and CWE Resources\n\n- [OWASP Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "266a70bf-e91c-31bb-8b33-7be81335992b",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when unescaped external data is used in an EJS template. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts into web pages viewed by other users. These scripts can steal sensitive information, perform actions on behalf of the user, or exploit other vulnerabilities in the user's browser.\n\nIn the provided code snippet, the product name is being outputted directly into the HTML without any form of escaping or sanitization. If the product name contains any HTML or JavaScript code, it will be executed by the browser.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always escape any external data that is being outputted into an HTML context. This can be done using the `escape` function provided by EJS, or by using a library that provides HTML escaping functionality.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code snippet:\n\n```ejs\n<td><%= ejs.escape(output.products[i].name) %></td>\n```\n\nIn this version, the `escape` function is used to escape any HTML or JavaScript code in the product name, preventing it from being executed by the browser.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## OWASP Resources\n\n- [Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)\n- [OWASP Cheat Sheet Series - XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "2a87e4aa-7bb1-34b0-9997-53cf7be00f72",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. This allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nEJS (Embedded JavaScript) templates are a popular templating engine in JavaScript. The vulnerability arises when the `<%- %>` syntax is used in EJS templates, which does not escape HTML entities, thus allowing potential Cross-Site Scripting (XSS) attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always use the `<%= %>` syntax in EJS templates, which escapes HTML entities. This will prevent potential XSS attacks. \n\nAlso, always validate and sanitize user input to ensure that it does not contain malicious scripts. Use a trusted library or framework that makes it easy to escape potentially harmful characters.\n\n## Source Code Fix Recommendation\n\nReplace the `<%- %>` syntax with `<%= %>` in your EJS templates. Here is the fixed code:\n\n```javascript\n<td><%= output.products[i].code %></td>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "a8c344fb-e0b9-3bd0-beba-bc74b30a9708",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when unescaped external data is used in an EJS template. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts into web pages viewed by other users. These scripts can steal sensitive information, perform actions on behalf of the user, or exploit other vulnerabilities in the user's browser.\n\nIn the provided code snippet, the vulnerability arises from the use of `<%-` instead of `<%=`, which results in the output not being escaped:\n\n```javascript\n<td><%- output.products[i].tags %></td>\n```\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always escape external data that is being output to the browser. This can be done by using `<%=` instead of `<%-` in EJS templates. This will ensure that any HTML special characters are properly escaped, preventing them from being interpreted as code by the browser.\n\n## Source Code Fix Recommendation\n\nHere is the fixed version of the code:\n\n```javascript\n<td><%= output.products[i].tags %></td>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS: A JavaScript templating engine.\n\n## OWASP and CWE Resources\n\n- [OWASP Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "45081c46-bcda-384a-96d1-9d48f46fb46a",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. This allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nIn the provided code snippet, the application is using EJS (Embedded JavaScript) templates to generate HTML markup with plain JavaScript. The `<%- %>` syntax in EJS is used to output the unescaped value into the template. This means that if `output.products[i].description` contains any malicious script, it will be executed when the page is rendered.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always escape untrusted data based on the HTML context (body, attribute, JavaScript, CSS, or URL) that the data will be placed into. In EJS, you can use `<%= %>` syntax to output the escaped value into the template.\n\n## Source Code Fix Recommendation\n\nReplace `<%- output.products[i].description %>` with `<%= output.products[i].description %>`. The updated code should look like this:\n\n```javascript\n<td><%= output.products[i].description %></td>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## References\n\n- [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "6b3d767a-cfe7-3b6c-87d8-4ff57074985f",
              "name": "\"Potential XSS Vulnerability from User-Controlled Data in HTML String\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Scripting (XSS) vulnerabilities occur when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nIn the provided JavaScript code, the application is executing a shell command with user-controlled input (`req.body.address`). This is a serious security risk as it allows an attacker to execute arbitrary commands on the server. Although this is not directly an XSS vulnerability, it can lead to XSS if the output of the command execution (`stdout` or `stderr`) contains user-controlled input and is rendered in a web page without proper escaping.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Avoid using `exec` with user-controlled input. If you need to run a shell command, consider using safer alternatives that allow you to pass arguments separately from the command itself, such as `child_process.execFile` or `child_process.spawn`.\n\n2. Always validate and sanitize user input. Use a library or framework that makes it easy to validate and sanitize input, and reject input that doesn't meet your criteria.\n\n3. Escape any user-controlled data that is included in a web page. This can prevent XSS attacks even if user-controlled data ends up in the output of a shell command.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `child_process.execFile`:\n\n```javascript\nconst { execFile } = require('child_process');\n\nlet address = req.body.address;\n// TODO: Add validation and sanitization of address here\n\nexecFile('ping', ['-c', '2', address], function (err, stdout, stderr) {\n    output = stdout + stderr;\n    // TODO: Add escaping of output here\n    res.render('app/ping', {\n        output: output\n    });\n});\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Express.js (for handling HTTP requests and responses)\n- EJS or another template engine (for rendering the web page)\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [OWASP Command Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  },
                  {
                    "id": "CWE-78",
                    "url": "https://cwe.mitre.org/data/definitions/78.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79",
                  "CWE-78"
                ]
              }
            },
            {
              "id": "7e2b05b3-38c9-35ad-9929-bf922d0085db",
              "name": "Unselected Field Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnselected Field Database Query Vulnerability in JavaScript occurs when a developer does not explicitly specify the fields to be returned from a database query. This can lead to the exposure of sensitive data if the query is used to return results directly to the client. An attacker can potentially gain access to data that they are not authorized to view.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should always explicitly specify the fields to be returned from a database query. This can be done by passing an array of field names to the `attributes` option in the query. \n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.Product.findAll({\n  attributes: ['field1', 'field2', 'field3'] // specify the fields to be returned\n}).then(products => {\n  // ...\n});\n```\n\nIn the above code, replace `'field1'`, `'field2'`, and `'field3'` with the actual field names of your `Product` model.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n\n## References\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-209: Information Exposure Through an Error Message](https://cwe.mitre.org/data/definitions/209.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-209",
                    "url": "https://cwe.mitre.org/data/definitions/209.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-209"
                ]
              }
            },
            {
              "id": "c8d00ddc-cb2f-3386-8938-1060a8e7a487",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but there is no error handling mechanism in place to catch and handle the error. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information in error messages.\n\nIn the provided code, the promise returned by `db.Product.findAll()` is not handled properly. If the promise is rejected (for example, if there is a problem connecting to the database), there is no error handling mechanism in place to catch and handle the error.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always have a `.catch()` block for every `.then()` block in your promises. The `.catch()` block will catch any errors that occur in the promise chain and handle them appropriately.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the provided code:\n\n```javascript\ndb.Product.findAll().then(products => {\n\toutput = {\n\t\tproducts: products\n\t}\n\tres.render('app/products', {\n\t\toutput: output\n\t})\n}).catch(err => {\n\t// Handle the error here\n\tconsole.error(err);\n\tres.status(500).send('An error occurred');\n});\n```\n\nIn this fixed code, if the promise is rejected, the error will be caught and logged to the console, and a 500 status code will be sent to the client.\n\n## Library Dependencies\n\nThe provided code appears to require the following libraries:\n\n- A database library that provides the `db.Product.findAll()` function. This could be Sequelize, for example.\n- An Express.js-like library that provides the `res.render()` function.\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_security_cheat_sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "caa78969-106f-30a0-815f-8634d1d554c0",
              "name": "Unselected Field Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unselected Field Database Query Vulnerability\" in JavaScript is a type of security vulnerability that occurs when a developer does not explicitly specify the fields to be returned from a database query. This can lead to the exposure of sensitive data if the query returns more data than intended. In the provided code, the `findAll` method is used without specifying the fields to be returned, which means all fields in the `Product` table will be returned.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should always explicitly specify the fields to be returned from a database query. This can be done using the `attributes` option in the `findAll` method. By doing this, developers can ensure that only the necessary data is returned, reducing the risk of exposing sensitive data.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.Product.findAll({\n    attributes: ['id', 'name', 'price'], // specify the fields to be returned\n    where: {\n        name: {\n            [Op.like]: '%' + req.body.name + '%'\n        }\n    }\n}).then(products => {\n    // ...\n});\n```\n\nIn this fixed version, the `findAll` method will only return the `id`, `name`, and `price` fields from the `Product` table.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n- Express: A fast, unopinionated, and flexible Node.js web application framework.\n\n## References\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-209: Information Exposure Through an Error Message](https://cwe.mitre.org/data/definitions/209.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-209",
                    "url": "https://cwe.mitre.org/data/definitions/209.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-209"
                ]
              }
            },
            {
              "id": "d956d5d7-fa6d-32d3-9cd0-0b60c5231067",
              "name": "XSS Vulnerability from User-Controlled Data in HTML String",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Scripting (XSS) vulnerabilities occur when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nIn the provided JavaScript code, the application is vulnerable to XSS because it includes user-controlled data (`req.body.name`) in the HTML output without proper escaping. This allows an attacker to inject malicious scripts by sending a specially crafted `name` parameter.\n\n## Mitigation Advice\n\nTo mitigate XSS vulnerabilities, you should:\n\n- Use a safe API which avoids the use of the interpreter entirely or provides a parameterized interface.\n- For any data that is included in the HTML output, use proper output encoding or escaping.\n- Apply context-sensitive encoding when modifying the browser document on the client side.\n- Use an appropriate Content Security Policy (CSP) to reduce the severity of any XSS vulnerabilities.\n\n## Source Code Fix Recommendation\n\nIn the provided code, you can mitigate the XSS vulnerability by using a template engine that automatically escapes user-controlled data. For example, if you are using the EJS template engine, you can use `<%= output.searchTerm %>` to include `searchTerm` in the HTML output. This will automatically escape any special characters.\n\n```javascript\ndb.Product.findAll({\n\twhere: {\n\t\tname: {\n\t\t\t[Op.like]: '%' + req.body.name + '%'\n\t\t}\n\t}\n}).then(products => {\n\toutput = {\n\t\tproducts: products,\n\t\tsearchTerm: req.body.name\n\t}\n\tres.render('app/products', {\n\t\toutput: output\n\t})\n})\n```\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n- Express: A fast, unopinionated, minimalist web framework for Node.js.\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "0e6fc9e5-03de-37aa-af56-1faa4c6e245a",
              "name": "Unselected Field Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unselected Field Database Query Vulnerability\" in JavaScript is a security flaw that occurs when a developer does not explicitly define the fields to be returned from a database query. This can lead to the exposure of sensitive data. In the provided code, the query is fetching a product by its 'id' from the database, but it does not specify which fields of the product should be returned. This means that all fields of the product, including potentially sensitive ones, will be returned.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should always explicitly define the fields to be returned from a database query. This can be done by adding a 'select' clause to the query, which specifies the fields to be returned. If a field is not specified in the 'select' clause, it will not be returned by the query.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.Product.find({\n    where: {\n        'id': req.query.id\n    },\n    attributes: ['id', 'name', 'description'] // specify the fields to be returned\n}).then(product => {\n    // ...\n});\n```\n\nIn this fixed version, the 'attributes' option is used to specify the fields to be returned by the query. Only the 'id', 'name', and 'description' fields of the product will be returned.\n\n## Library Dependencies\n\nThe provided code appears to be using the Sequelize ORM for Node.js. Therefore, the following library dependencies are required:\n\n- `sequelize`: This is the main Sequelize library.\n- `pg` or `mysql`: These are the database drivers. You should install the one that matches your database system.\n- `express`: This is used to handle HTTP requests and responses.\n\n## References\n\n- [OWASP - SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-209: Information Exposure Through an Error Message](https://cwe.mitre.org/data/definitions/209.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-209",
                    "url": "https://cwe.mitre.org/data/definitions/209.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-209"
                ]
              }
            },
            {
              "id": "3f9d0612-751a-37dd-91b8-d38a6efa8402",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a Promise is rejected, but this rejection is not caught or handled. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information or lead to other security vulnerabilities.\n\nIn the provided code, the Promise returned by `db.Product.find()` is not being handled for a case where it might get rejected. If for any reason the Promise is rejected (for example, a database error), there is no code to handle this rejection, which could lead to unhandled Promise rejection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always handle Promise rejections. This can be done by adding a `.catch()` block to the Promise chain. The `.catch()` block will catch any errors that occur in the Promise chain and allow you to handle them appropriately.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the provided code:\n\n```javascript\ndb.Product.find({\n\twhere: {\n\t\t'id': req.query.id\n\t}\n}).then(product => {\n\tif (!product) {\n\t\tproduct = {}\n\t}\n\toutput = {\n\t\tproduct: product\n\t}\n\tres.render('app/modifyproduct', {\n\t\toutput: output\n\t})\n}).catch(err => {\n\t// Handle the error here\n\tconsole.error(err);\n\tres.status(500).send('An error occurred');\n});\n```\n\nIn the above code, a `.catch()` block is added to handle any errors that occur in the Promise chain.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- A Promise-compatible database library (such as Sequelize) for `db.Product.find()`.\n- An Express.js-compatible server for handling requests and responses (`req`, `res`).\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_security_cheat_sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "62bc3e5d-aa43-36a8-9c56-36406f37f48a",
              "name": "Unverified User Input IDOR Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnverified User Input IDOR (Insecure Direct Object References) Vulnerability is a type of security vulnerability that occurs when a function with no access control is used to access a specific resource directly. In JavaScript, this vulnerability can occur when a user-supplied input is used directly to access a database object without proper validation or authorization checks. This can allow an attacker to manipulate the input to access unauthorized data.\n\nIn the provided code snippet, the vulnerability arises from the use of `req.body.id` directly in the database query without any validation or authorization checks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate user input: Ensure that the user input matches the expected format and values. This can be done using regular expressions or built-in validation functions.\n\n2. Implement access control: Ensure that the user has the necessary permissions to access the requested resource. This can be done by checking the user's role or permissions before executing the database query.\n\n3. Use parameterized queries: This can help prevent SQL injection attacks by ensuring that user input is always treated as a literal value and not part of the SQL command.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```javascript\n// Assuming `userId` is the authenticated user's ID\nif (req.user.id !== req.body.id) {\n    return res.status(403).send(\"Unauthorized access\");\n}\n\ndb.Product.find({\n    where: {\n        'id': req.body.id\n    }\n}).then(product => {\n    // ...\n});\n```\n\n## Library Dependencies\n\nThe provided code snippet seems to be using the following libraries:\n\n- Express.js: For handling HTTP requests and responses.\n- Sequelize: For interacting with the database.\n\n## References\n\n- [CWE-639: Authorization Bypass Through User-Controlled Key](https://cwe.mitre.org/data/definitions/639.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-639",
                    "url": "https://cwe.mitre.org/data/definitions/639.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-639"
                ]
              }
            },
            {
              "id": "2f5df063-de60-3c21-a023-00eed651128b",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but there is no error handling mechanism in place to catch and handle the error. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information in error messages.\n\nIn the provided code, the promise returned by `db.Product.find()` is not properly handled in case of rejection. If the promise is rejected, the application will crash because there is no `.catch()` block to handle the error.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always include a `.catch()` block when working with promises to handle any potential errors. This will prevent the application from crashing and can provide a more graceful way to handle errors.\n\n## Source Code Fix Recommendation\n\nHere is the fixed code:\n\n```javascript\ndb.Product.find({\n\twhere: {\n\t\t'id': req.body.id\n\t}\n}).then(product => {\n\tif (!product) {\n\t\tproduct = new db.Product()\n\t}\n\tproduct.code = req.body.code\n\tproduct.name = req.body.name\n\tproduct.description = req.body.description\n\tproduct.tags = req.body.tags\n\tproduct.save().then(p => {\n\t\tif (p) {\n\t\t\treq.flash('success', 'Product added/modified!')\n\t\t\tres.redirect('/app/products')\n\t\t}\n\t}).catch(err => {\n\t\toutput = {\n\t\t\tproduct: product\n\t\t}\n\t\treq.flash('danger',err)\n\t\tres.render('app/modifyproduct', {\n\t\t\toutput: output\n\t\t})\n\t})\n}).catch(err => {\n\tconsole.error(err);\n\t// Handle the error appropriately here\n});\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Sequelize (for the `db.Product.find()` and `product.save()` methods)\n- Express (for the `req` and `res` objects)\n- Connect-flash (for the `req.flash()` method)\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "ccc3f7d3-17f7-3c2e-a1bf-d4b3c5003260",
              "name": "Unverified User Input IDOR Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnverified User Input IDOR (Insecure Direct Object References) Vulnerability is a type of security vulnerability that occurs when a function with no access control is used to access a specific resource directly. In the context of JavaScript, this vulnerability can occur when a user is able to manipulate input to access unauthorized data. In the provided code, the vulnerability lies in the fact that the user input is directly used to query the database without any validation or sanitization.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to implement proper access control checks and validate and sanitize all user inputs. Access control checks ensure that a user can only access data that they are authorized to access. Input validation and sanitization help to prevent malicious input from being executed as part of the query.\n\n## Source Code Fix Recommendation\n\n```javascript\nvar userId = parseInt(req.body.id, 10);\n\nif (isNaN(userId)) {\n    // Handle error\n} else {\n    db.User.find({\n        where: {\n            'id': userId\n        }\t\t\n    }).then(user => {\n        // ...\n    });\n}\n```\n\nIn the above code, the user input is first parsed into an integer. If the input is not a valid number, an error is handled. This helps to prevent malicious input from being executed as part of the query.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Express.js: A web application framework for Node.js.\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n\n## References\n\n- [OWASP Top 10-2017 A5-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-89"
                ]
              }
            },
            {
              "id": "15724e00-e71c-3b1d-906e-22bafe0e35de",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but the rejection is not caught or handled. This can lead to unexpected application behavior and potential security vulnerabilities. In the provided code, if the `db.User.find` promise is rejected (for example, if there is a database error), there is no `.catch` block to handle the error, which could lead to an Unhandled Promise Rejection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle promise rejections by adding a `.catch` block after your `.then` block. This allows you to handle any errors that occur during the execution of the promise. In addition, you should also consider using `async/await` syntax, which can make your code more readable and easier to understand.\n\n## Source Code Fix Recommendation\n\nHere is the fixed code:\n\n```javascript\ndb.User.find({\n\twhere: {\n\t\t'id': req.body.id\n\t}\t\t\n}).then(user =>{\n\tif(req.body.password.length>0){\n\t\tif(req.body.password.length>0){\n\t\t\tif (req.body.password == req.body.cpassword) {\n\t\t\t\tuser.password = bCrypt.hashSync(req.body.password, bCrypt.genSaltSync(10), null)\n\t\t\t}else{\n\t\t\t\treq.flash('warning', 'Passwords dont match')\n\t\t\t\tres.render('app/useredit', {\n\t\t\t\t\tuserId: req.user.id,\n\t\t\t\t\tuserEmail: req.user.email,\n\t\t\t\t\tuserName: req.user.name,\n\t\t\t\t})\n\t\t\t\treturn\t\t\n\t\t\t}\n\t\t}else{\n\t\t\treq.flash('warning', 'Invalid Password')\n\t\t\tres.render('app/useredit', {\n\t\t\t\tuserId: req.user.id,\n\t\t\t\tuserEmail: req.user.email,\n\t\t\t\tuserName: req.user.name,\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n\tuser.email = req.body.email\n\tuser.name = req.body.name\n\tuser.save().then(function () {\n\t\treq.flash('success',\"Updated successfully\")\n\t\tres.render('app/useredit', {\n\t\t\tuserId: req.body.id,\n\t\t\tuserEmail: req.body.email,\n\t\t\tuserName: req.body.name,\n\t\t})\n\t}).catch(err => {\n\t\t// Handle the error here\n\t\tconsole.error(err);\n\t})\n}).catch(err => {\n\t// Handle the error here\n\tconsole.error(err);\n});\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- A database library that supports promises (such as Sequelize)\n- Express.js for handling HTTP requests and responses\n- bcrypt for hashing passwords\n- A flash messaging library (such as connect-flash)\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "9e7f935e-1419-32f9-a5a8-faa28a812b45",
              "name": "\"Open Redirect Vulnerability in URL Building Application\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nOpen Redirect Vulnerability in URL Building Application is a security flaw in JavaScript applications that allows an attacker to redirect users to malicious websites. This vulnerability occurs when an application incorporates user input into a URL redirect without validating the input. In the provided code, the application redirects the user to the URL provided in the query string without any validation, which can be exploited by an attacker.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using user input directly in URL redirect functions. If it is necessary to use user input, it should be validated and sanitized before use. The application should only allow redirects to known, trusted URLs.\n\n## Source Code Fix Recommendation\n\n```javascript\n// Assuming express.js is used\nvar express = require('express');\nvar app = express();\n\napp.get('/redirect', function(req, res) {\n    var url = req.query.url;\n    // Validate the URL before redirecting\n    if (validateURL(url)) {\n        res.redirect(url);\n    } else {\n        // Handle invalid URL\n        res.redirect('/error');\n    }\n});\n\nfunction validateURL(url) {\n    // Implement URL validation logic here\n    // For example, check if the URL is in a list of trusted URLs\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- Express.js\n\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)\n- [CWE-601: URL Redirection to Untrusted Site ('Open Redirect')](https://cwe.mitre.org/data/definitions/601.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-601",
                    "url": "https://cwe.mitre.org/data/definitions/601.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-601"
                ]
              }
            },
            {
              "id": "de1c00f3-1236-30a1-858c-433ce6f12886",
              "name": "\"Deprecated mathjs.eval() is susceptible to code injection; use mathjs.evaluate() instead.\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `mathjs.eval()` function in the Math.js library is deprecated and is known to be susceptible to code injection attacks. This is a serious security vulnerability where an attacker can inject malicious code into the application, which is then executed by the application. This can lead to a variety of attacks, such as data theft, data corruption, denial of service, or even full system compromise.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to replace the deprecated `mathjs.eval()` function with the `mathjs.evaluate()` function, which is not susceptible to code injection attacks. \n\nAdditionally, it is always a good practice to validate and sanitize all user inputs to prevent code injection attacks. Never trust user input and always assume it could be malicious.\n\n## Source Code Fix Recommendation\n\nReplace the vulnerable code:\n\n```javascript\noutput: mathjs.eval(req.body.eqn)\n```\n\nWith the secure code:\n\n```javascript\noutput: mathjs.evaluate(req.body.eqn)\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n\n## References\n\n- [OWASP Code Injection](https://owasp.org/www-community/attacks/Code_Injection)\n- [CWE-94: Improper Control of Generation of Code ('Code Injection')](https://cwe.mitre.org/data/definitions/94.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-94",
                    "url": "https://cwe.mitre.org/data/definitions/94.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-94"
                ]
              }
            },
            {
              "id": "1e4caf67-5bfb-3038-9006-891aefedc48b",
              "name": "Unfiltered Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnfiltered Database Query Vulnerability in JavaScript is a security flaw that occurs when a developer does not properly sanitize or filter input data before using it in a database query. This can lead to SQL Injection attacks where an attacker can manipulate the query to gain unauthorized access to the database, modify the database, or even delete data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should always sanitize and validate input data before using it in a database query. This can be done by using parameterized queries or prepared statements, which separate the data from the query itself, making it impossible for an attacker to manipulate the query.\n\n## Source Code Fix Recommendation\n\nThe code example provided does not show any direct vulnerability to Unfiltered Database Query as it does not use any user input in the query. However, to ensure safety, it's recommended to use Sequelize's built-in protection against SQL Injection. Sequelize is an ORM for Node.js and it automatically escapes all input to prevent SQL Injection.\n\n```javascript\ndb.User.findAll({\n  where: {\n    // Add your conditions here\n  }\n}).then(users => {\n  // Your code here\n});\n```\n\n## Library Dependencies\n\nThe code example provided requires the following library dependencies:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n\n## References\n\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-89"
                ]
              }
            },
            {
              "id": "3b9b1a65-6df9-34c9-865c-92e11c2bd3f6",
              "name": "\"Object or Remote Code Injection Vulnerability in 'unserialize()' or 'deserialize()' Function\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `unserialize()` or `deserialize()` function in JavaScript is used to convert a serialized string back into a JavaScript object. However, this function can be exploited by an attacker to execute arbitrary code on the server. This is known as an Object or Remote Code Injection vulnerability.\n\nThe vulnerability occurs when user-supplied data is passed directly to the `unserialize()` or `deserialize()` function without proper validation or sanitization. An attacker can craft a serialized string that, when unserialized, results in the execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using the `unserialize()` or `deserialize()` function with user-supplied data. If this is not possible, you should ensure that the data is properly validated and sanitized before it is passed to the function.\n\n## Source Code Fix Recommendation\n\nIn the provided code example, the `unserialize()` function is used with data from a file uploaded by the user. This is a potential security risk. A safer approach would be to validate and sanitize the data before unserializing it. However, the best solution would be to avoid using `unserialize()` with user-supplied data altogether.\n\n```javascript\n// Instead of this:\nvar products = serialize.unserialize(req.files.products.data.toString('utf8'));\n\n// Do this:\nvar products;\ntry {\n    products = JSON.parse(req.files.products.data.toString('utf8'));\n} catch (e) {\n    // Handle error\n}\n```\n\nIn this revised code, `JSON.parse()` is used instead of `unserialize()`. This function is safer because it does not allow the execution of arbitrary code.\n\n## Library Dependencies\n\nThe provided code example requires the following library dependencies:\n\n- `serialize`: This library provides the `unserialize()` function.\n- `express`: This library is used to handle HTTP requests and responses.\n\n## OWASP and CWE Resources\n\n- [OWASP Top 10 2017: A8-Insecure Deserialization](https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization)\n- [CWE-502: Deserialization of Untrusted Data](https://cwe.mitre.org/data/definitions/502.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-502"
                ]
              }
            },
            {
              "id": "58d74204-e872-36aa-836d-ab10502a5418",
              "name": "Insecure Cryptographic Hash Identified: MD5, SHA1 Inadequate for Security; bcrypt, scrypt, Argon2 Recommended for Passwords; SHA-256+ Suggested for Integrity Checks.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nInsecure Cryptographic Hash Identified vulnerability refers to the use of weak cryptographic hashes, such as MD5 and SHA1, which are no longer considered secure for many cryptographic operations. These hashes have known vulnerabilities and are susceptible to collision attacks, where two different inputs produce the same hash output, thus compromising the security of the system.\n\nIn JavaScript, this vulnerability can occur when using libraries such as 'md5' to hash sensitive data like passwords. The use of stronger cryptographic hashes like bcrypt, scrypt, or Argon2 is recommended for password hashing, while SHA-256 or higher is suggested for integrity checks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to replace the use of weak cryptographic hashes with stronger ones. For password hashing, consider using bcrypt, scrypt, or Argon2. For integrity checks, consider using SHA-256 or higher.\n\n## Source Code Fix Recommendation\n\nReplace the 'md5' library with a more secure hashing library. Here is an example using the 'bcrypt' library for password hashing:\n\n```javascript\nvar bcrypt = require('bcrypt');\nvar saltRounds = 10;\n\nbcrypt.hash('myPassword', saltRounds, function(err, hash) {\n  // Store hash in your password DB.\n});\n```\n\n## Library Dependencies\n\nThe 'bcrypt' library is required for the code example to execute properly.\n\n## OWASP Resources\n\n- [Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-327",
                    "url": "https://cwe.mitre.org/data/definitions/327.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-327"
                ]
              }
            },
            {
              "id": "ce987a29-92e0-3e8b-aff6-d07dc2295ee9",
              "name": "Unverified User Input IDOR Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnverified User Input IDOR (Insecure Direct Object References) Vulnerability is a type of security vulnerability that occurs when a function with no proper access control is used to access specific resources directly by modifying the value of a parameter used in a direct object reference. In JavaScript, this vulnerability can occur when a user-supplied input is used directly to query the database without any validation or sanitization.\n\nIn the provided code snippet, the application is directly using the user-supplied login to find a user in the database. An attacker can manipulate the 'login' parameter to gain unauthorized access to other users' data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Always validate and sanitize user inputs before using them in database queries.\n2. Implement proper access control checks to ensure that a user can only access data that they are authorized to access.\n3. Use parameterized queries or prepared statements to prevent SQL injection attacks.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```javascript\nconst Sequelize = require('sequelize');\nconst Op = Sequelize.Op;\n\ndb.User.find({\n\twhere: {\n\t\t'login': {\n\t\t\t[Op.eq]: req.body.login\n\t\t}\n\t}\n}).then(user => {\n\t// ...\n});\n```\n\nIn this fix, we are using Sequelize's operators to ensure that the query is safe from SQL injection attacks. We are also validating and sanitizing the user input before using it in the query.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `sequelize`: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n\n## References\n\n- [CWE-639: Authorization Bypass Through User-Controlled Key](https://cwe.mitre.org/data/definitions/639.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-639",
                    "url": "https://cwe.mitre.org/data/definitions/639.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-639"
                ]
              }
            },
            {
              "id": "c5680213-67cb-3707-9b6c-1ce025528422",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a Promise is rejected, but there is no error handling mechanism in place to catch and handle the error. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information in error messages.\n\nIn the provided code, the Promise returned by `db.User.find()` is not handled properly. If the Promise is rejected (for example, if there is a problem connecting to the database), the error will not be caught and handled, and the application may crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle Promise rejections. This can be done by chaining a `.catch()` block to the Promise, which will catch and handle any errors that occur. The `.catch()` block should contain code to handle the error appropriately, such as logging the error and returning a response to the client indicating that an error occurred.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.User.find({\n\twhere: {\n\t\t'login': req.body.login\n\t}\n}).then(user => {\n\tif (user) {\n\t\t// Send reset link via email happens here\n\t\treq.flash('info', 'Check email for reset link')\n\t\tres.redirect('/login')\n\t} else {\n\t\treq.flash('danger', \"Invalid login username\")\n\t\tres.redirect('/forgotpw')\n\t}\n}).catch(err => {\n\t// Handle the error appropriately here\n\tconsole.error(err);\n\tres.status(500).send('An error occurred');\n});\n```\n\n## Library Dependencies\n\nThe provided code appears to require the following libraries:\n\n- A database library that provides the `db.User.find()` function. This could be Sequelize, for example.\n- Express.js, for handling HTTP requests and responses.\n- The `req.flash()` function suggests that the `connect-flash` middleware for Express.js is being used.\n\n## OWASP and CWE Links\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "7b866c05-60b3-3d40-8e2b-070af8617634",
              "name": "Unselected Field Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unselected Field Database Query Vulnerability\" in JavaScript is a security flaw that occurs when a developer does not explicitly define the fields to be returned from a database query. This can lead to the exposure of sensitive data. In the provided code, the `find` method is used to retrieve a user based on the `login` field. However, all fields associated with the user are returned, which may include sensitive data such as passwords or personal information.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should explicitly define the fields to be returned from the database query. This can be done using the `attributes` option in the `find` method. By specifying only the necessary fields, developers can prevent the exposure of sensitive data.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.User.find({\n    attributes: ['login', 'other_field'], // specify the fields to be returned\n    where: {\n        'login': req.query.login\n    }\n}).then(user => {\n    // ...\n});\n```\n\nIn this code, only the `login` and `other_field` fields are returned from the database query.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- `sequelize`: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n- `express`: A fast, unopinionated, minimalist web framework for Node.js.\n\n## References\n\n- [OWASP - Query Parameterization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html)\n- [CWE-209: Information Exposure Through an Error Message](https://cwe.mitre.org/data/definitions/209.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-209",
                    "url": "https://cwe.mitre.org/data/definitions/209.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-209"
                ]
              }
            },
            {
              "id": "a7464f96-d4d8-381b-aa8b-37c31c0eb135",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but the rejection is not caught or handled. This can lead to unexpected application behavior, including crashes and unhandled exceptions. In the context of Node.js, an unhandled promise rejection can cause the Node.js process to terminate.\n\nIn the provided code, the promise returned by `db.User.find()` is not properly handled. If the promise is rejected (for example, if there is a problem connecting to the database), the rejection will not be caught and the application may crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle promise rejections. This can be done by adding a `.catch()` block to the promise chain. The `.catch()` block will be called if the promise is rejected.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the provided code:\n\n```javascript\ndb.User.find({\n\twhere: {\n\t\t'login': req.query.login\n\t}\n}).then(user => {\n\tif (user) {\n\t\tif (req.query.token == md5(req.query.login)) {\n\t\t\tres.render('resetpw', {\n\t\t\t\tlogin: req.query.login,\n\t\t\t\ttoken: req.query.token\n\t\t\t})\n\t\t} else {\n\t\t\treq.flash('danger', \"Invalid reset token\")\n\t\t\tres.redirect('/forgotpw')\n\t\t}\n\t} else {\n\t\treq.flash('danger', \"Invalid login username\")\n\t\tres.redirect('/forgotpw')\n\t}\n}).catch(err => {\n\t// Handle the error here\n\tconsole.error(err);\n\treq.flash('danger', \"An error occurred\")\n\tres.redirect('/forgotpw')\n});\n```\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- A database library that provides the `db.User.find()` method. This could be Sequelize, Mongoose, or a similar library.\n- Express.js, for handling HTTP requests and responses.\n- The `md5` library, for hashing the login.\n- A flash messaging library, such as `connect-flash`, for displaying flash messages.\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "5640a9f3-0a6b-31b1-89b7-afa1ae4a5298",
              "name": "MD5 User-Controlled Input Leads to Guessable Tokens Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"MD5 User-Controlled Input Leads to Guessable Tokens Vulnerability\" is a security flaw in JavaScript where an attacker can guess or brute-force the MD5 hash of a user's login information to generate a valid token. This is possible because MD5 is a weak hashing algorithm that is susceptible to collision attacks, where different inputs produce the same hash. If an attacker can guess or brute-force the MD5 hash of a user's login, they can impersonate the user and gain unauthorized access to the system.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using MD5 for any security critical functionality, such as token generation. Instead, use a stronger, cryptographically secure hashing algorithm like SHA-256. Additionally, you should avoid using user-controlled input directly in security critical functionality. Instead, use a server-side secret in combination with the user's login to generate the token.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the vulnerability using the `crypto` library in Node.js:\n\n```javascript\nconst crypto = require('crypto');\n\n// Generate a server-side secret\nconst secret = 'your-server-side-secret';\n\n// Use the secret and the user's login to generate the token\nconst hash = crypto.createHmac('sha256', secret)\n                   .update(req.query.login)\n                   .digest('hex');\n\nif (req.query.token == hash) {\n  // ...\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `crypto`: This is a built-in Node.js module for cryptographic functionality.\n\n## References\n\n- [OWASP - Insecure Cryptographic Storage](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)\n- [CWE-328: Reversible One-Way Hash](https://cwe.mitre.org/data/definitions/328.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-328"
                ]
              }
            },
            {
              "id": "83ca2a00-6d50-3d3c-b58c-b3ebbaadfd82",
              "name": "Unverified User Input IDOR Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnverified User Input IDOR (Insecure Direct Object References) Vulnerability is a type of security vulnerability that occurs when a function with no proper access control is used to access specific resources directly. In JavaScript, this vulnerability can occur when a user-supplied input is used directly to query a database without proper validation or authorization checks. This can allow an attacker to manipulate the input to gain unauthorized access to data.\n\nIn the provided code snippet, the application is using the user-supplied login name (`req.body.login`) directly to query the database for a user. If an attacker can guess or brute-force a valid login name, they can potentially gain unauthorized access to that user's data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Always validate user-supplied inputs: Ensure that the input matches the expected format and length. This can help prevent SQL Injection attacks.\n\n2. Implement proper access control: Ensure that the user is authorized to access the requested resource. This can help prevent unauthorized access to data.\n\n3. Use parameterized queries or prepared statements: This can help prevent SQL Injection attacks by ensuring that user-supplied inputs are always treated as literal values, not part of the SQL command.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```javascript\n// Assuming Express.js and Sequelize ORM\napp.post('/login', (req, res) => {\n  // Validate input\n  if (!req.body.login || typeof req.body.login !== 'string' || req.body.login.length > 100) {\n    return res.status(400).send('Invalid login');\n  }\n\n  // Query database\n  db.User.find({\n    where: {\n      'login': req.body.login\n    }\n  }).then(user => {\n    // Check if user exists\n    if (!user) {\n      return res.status(404).send('User not found');\n    }\n\n    // Check if user is authorized to access the requested resource\n    if (req.session.userId !== user.id) {\n      return res.status(403).send('Unauthorized');\n    }\n\n    // Continue processing...\n  });\n});\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- Express.js: A web application framework for Node.js.\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n\n## References\n\n- [CWE-639: Authorization Bypass Through User-Controlled Key](https://cwe.mitre.org/data/definitions/639.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-639",
                    "url": "https://cwe.mitre.org/data/definitions/639.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-639"
                ]
              }
            },
            {
              "id": "cf96834b-e589-3399-b7af-68f942a5a2e7",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but the rejection is not caught or handled. This can lead to unexpected application behavior, including crashes and unhandled exceptions. In the provided code, if the `user.save()` promise is rejected, there is no error handling mechanism in place to catch and handle the rejection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always include a `.catch()` block when working with promises to handle any potential rejections. This allows you to define how your application should respond, preventing unexpected behavior and improving the robustness of your code.\n\n## Source Code Fix Recommendation\n\nHere is the fixed version of the code:\n\n```javascript\ndb.User.find({\n    where: {\n        'login': req.body.login\n    }\n}).then(user => {\n    if (user) {\n        if (req.body.token == md5(req.body.login)) {\n            user.password = bCrypt.hashSync(req.body.password, bCrypt.genSaltSync(10), null)\n            user.save().then(function () {\n                req.flash('success', \"Password successfully reset\")\n                res.redirect('/login')\n            }).catch(err => {\n                console.error(err);\n                req.flash('danger', \"An error occurred while resetting password\")\n                res.redirect('/forgotpw')\n            })\n        } else {\n            req.flash('danger', \"Invalid reset token\")\n            res.redirect('/forgotpw')\n        }\n    } else {\n        req.flash('danger', \"Invalid login username\")\n        res.redirect('/forgotpw')\n    }\n}).catch(err => {\n    console.error(err);\n    req.flash('danger', \"An error occurred while finding user\")\n    res.redirect('/forgotpw')\n})\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Sequelize (for `db.User.find()`)\n- Express.js (for `req`, `res`, `req.body`, `req.flash()`, `res.redirect()`)\n- bcryptjs (for `bCrypt.hashSync()`, `bCrypt.genSaltSync()`)\n- md5 (for `md5()`)\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "5f90b615-344e-3cf8-88ec-191e098a501e",
              "name": "MD5 User-Controlled Input Predictability Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nMD5 User-Controlled Input Vulnerability in JavaScript refers to a security flaw where an application uses the MD5 hashing algorithm to verify user-controlled input. The MD5 algorithm is considered weak due to its vulnerability to collision attacks, where two different inputs produce the same hash. This can allow an attacker to craft specific inputs that produce the same MD5 hash, bypassing security checks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a more secure hashing algorithm such as SHA-256 or bcrypt. Additionally, it is important to validate and sanitize all user-controlled input to prevent injection attacks.\n\n## Source Code Fix Recommendation\n\nReplace the MD5 hashing with a more secure algorithm. Here is an example using the bcrypt library:\n\n```javascript\nconst bcrypt = require('bcrypt');\n\n// Generate hash\nconst salt = bcrypt.genSaltSync(10);\nconst hash = bcrypt.hashSync(req.body.login, salt);\n\n// Compare\nif (req.body.token == hash) {\n  // ...\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- bcrypt\n\n## References\n\n- [OWASP - Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n- [CWE-328: Reversible One-Way Hash](https://cwe.mitre.org/data/definitions/328.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-328",
                    "url": "https://cwe.mitre.org/data/definitions/328.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-328"
                ]
              }
            },
            {
              "id": "9225247f-64c7-3daa-84ac-d02dd219a622",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but the rejection is not caught or handled. This can lead to unexpected application behavior and potential security vulnerabilities. In the provided code, if the promise returned by `db.User.findOne()` is rejected (for example, due to a database error), the rejection will not be caught and will result in an Unhandled Promise Rejection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle promise rejections. This can be done by adding a `.catch()` block to the promise chain, which will catch any errors that occur in the preceding `.then()` blocks. In the `.catch()` block, you can handle the error appropriately, for example by logging the error and returning a response indicating that an error occurred.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the provided code:\n\n```javascript\ndb.User.findOne({\n    where: {\n        'id': uid\n    }\n}).then(function (user) {\n    if (user) {\n        done(null, user);\n    } else {\n        done(null, false)\n    }\n}).catch(function (error) {\n    // Handle the error appropriately here\n    console.error(error);\n    done(error);\n});\n```\n\nIn this fixed code, if the promise is rejected, the `.catch()` block will catch the error, log it to the console, and call `done()` with the error.\n\n## Library Dependencies\n\nThe provided code appears to require the following library dependencies:\n\n- Sequelize (or a similar ORM library) for the `db.User.findOne()` function.\n- A library or framework that provides the `done()` function, such as Passport.js.\n\n## References\n\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "866313ba-f531-3b3a-acc7-36dbe347579d",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a Promise is rejected, but this rejection is not caught or handled. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information or lead to other security vulnerabilities.\n\nIn the provided code, the Promise returned by `db.User.findOne()` is not being handled for a case where it might get rejected. This could happen, for example, if there is a problem with the database connection or a query error.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle Promise rejections. This can be done by adding a `.catch()` block to the Promise chain, which will catch any errors that occur in the Promise or in any of the `.then()` blocks.\n\n## Source Code Fix Recommendation\n\nHere is how you could modify the provided code to handle Promise rejections:\n\n```javascript\ndb.User.findOne({\n    where: {\n        'login': username\n    }\n}).then(function (user) {\n    if (!user) {\n        return done(null, false, req.flash('danger', 'Invalid Credentials'))\n    }\n    if (!isValidPassword(user, password)) {\n        return done(null, false, req.flash('danger', 'Invalid Credentials'))\n    }\n    return done(null, user);\n}).catch(function (error) {\n    // Handle the error here\n    console.error(error);\n    return done(error);\n});\n```\n\nIn the `.catch()` block, you should handle the error appropriately for your application. This might involve logging the error, returning an error response, or retrying the operation, depending on the nature of the error and the requirements of your application.\n\n## Library Dependencies\n\nThe provided code appears to require the following libraries:\n\n- A database library that provides the `db.User.findOne()` function. This could be Sequelize, for example.\n- The `done` function, which is typically provided by Passport.js in the context of authentication.\n- The `req.flash()` function, which is provided by the `connect-flash` middleware for Express.js.\n\n## References\n\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "c2ed1196-9838-3188-9305-8e74c53a8388",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but the rejection is not caught or handled. This can lead to unexpected application behavior, including crashes, and can potentially be exploited by attackers to cause denial of service or other malicious activities.\n\nIn the provided code, the promise returned by `db.User.create()` is not handled for rejection. If the promise is rejected (for example, due to a database error), the rejection will not be caught and the application may crash.\n\n## Mitigation\n\nTo mitigate this vulnerability, always handle promise rejections. This can be done by adding a `.catch()` block to the promise chain, or by using `async/await` with a `try/catch` block.\n\n## Code Fix\n\nHere is the fixed code:\n\n```javascript\ndb.User.findOne({\n    where: {\n        'email': username\n    }\n}).then(function (user) {\n    if (user) {\n        return done(null, false, req.flash('danger', 'Account Already Exists'));\n    } else {\n        if (req.body.email && req.body.password && req.body.username && req.body.cpassword && req.body.name) {\n            if (req.body.cpassword == req.body.password) {\n                db.User.create({\n                    email: req.body.email,\n                    password: createHash(password),\n                    name: req.body.name,\n                    login: username\n                }).then(function (user) {\n                    return done(null, user)\n                }).catch(function (error) {\n                    // Handle the error here\n                    console.error(error);\n                    return done(null, false, req.flash('danger', 'Database error'));\n                });\n            } else {\n                return done(null, false, req.flash('danger', 'Passwords dont match'));\n            }\n        } else {\n            return done(null, false, req.flash('danger', 'Input field(s) missing'));\n        }\n    }\n}).catch(function (error) {\n    // Handle the error here\n    console.error(error);\n    return done(null, false, req.flash('danger', 'Database error'));\n});\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Sequelize (for database operations)\n- Express (for handling HTTP requests)\n- Connect-flash (for flash messages)\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "f40d37bc-a799-33d2-976e-505fb388e17a",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" is a type of vulnerability in JavaScript that occurs when a promise is rejected, but there is no error handling mechanism in place to catch and handle the error. This can lead to unexpected application behavior, including crashes and potential security risks.\n\nIn the provided code, the `sequelize.authenticate()` function returns a promise. If the promise is rejected (for example, if the database connection fails), there is no `catch` block to handle the error. This can lead to an Unhandled Promise Rejection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always include error handling when working with promises. This can be done by chaining a `catch` block to the promise, which will be executed if the promise is rejected. The `catch` block should contain code to handle the error appropriately.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\nsequelize\n  .authenticate()\n  .then(function () {\n    console.log('Connection has been established successfully.');\n  })\n  .catch(function (err) {\n    console.error('Unable to connect to the database:', err);\n  });\n```\n\nIn this version of the code, if the promise returned by `sequelize.authenticate()` is rejected, the `catch` block will be executed, logging the error to the console.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- `sequelize`: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_security_cheat_sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "073f2b99-5b1e-39a8-8ef2-1116fdbbfb79",
              "name": "\"Potential Out-of-Destination Writing Vulnerability\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nPotential Out-of-Destination Writing Vulnerability in JavaScript refers to a security flaw where an attacker can manipulate the path of a file or directory, allowing them to write or overwrite files outside of the intended destination. This can lead to unauthorized access to sensitive data, corruption of system files, or execution of malicious code.\n\nIn the provided code snippet, the vulnerability arises from the use of `sequelize.import()` function with a file path that could potentially be manipulated by an attacker.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to validate and sanitize all user inputs. Avoid using user-supplied input directly in file paths. If it's necessary to use user input in file paths, ensure that the path stays within the intended directory.\n\n## Source Code Fix Recommendation\n\n```javascript\nvar path = require('path');\nvar file = 'filename'; // Ensure this value is from a trusted source\n\nvar safePath = path.normalize(path.join(__dirname, file)).startsWith(path.normalize(__dirname));\n\nif (safePath) {\n  var model = sequelize.import(path.join(__dirname, file));\n} else {\n  console.error('Potential path manipulation detected');\n}\n```\n\nIn the above code, `path.normalize()` is used to resolve any '..' in the path, and `startsWith()` is used to ensure the path stays within the intended directory.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n- Path: A core Node.js module for handling and transforming file paths.\n\n## References\n\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)\n- [CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')](https://cwe.mitre.org/data/definitions/22.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-22"
                ]
              }
            },
            {
              "id": "2992bbde-9c2e-361f-91b2-31865be4434c",
              "name": "\"Potential XSS Vulnerability from User-Controlled Data in HTML String\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Scripting (XSS) vulnerabilities occur when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nIn the provided code, the application is vulnerable to XSS because it includes user-controlled data (`req.params.vuln`) in the HTML response without proper output encoding or validation.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. **Validate Input**: User input should be validated as strictly as possible on arrival, given the kind of content that it is expected to contain.\n2. **Encode Data**: User-controlled data included in the HTML response should be HTML entity encoded to prevent the browser from interpreting it as HTML/JavaScript code.\n3. **Use Appropriate Response Headers**: To prevent XSS in HTTP responses that aren't intended to contain any HTML or JavaScript, you can use the `Content-Type` and `X-Content-Type-Options` headers to ensure that browsers interpret the responses in the way you intend.\n4. **Content Security Policy**: Use Content Security Policy (CSP) to reduce the severity of any XSS vulnerabilities that still occur.\n\n## Source Code Fix\n\nThe Express.js framework provides a way to escape HTML through the `escape-html` module. Here is how you can use it:\n\n```javascript\nvar escapeHtml = require('escape-html');\n\nres.render('vulnerabilities/layout', {\n\tvuln: escapeHtml(req.params.vuln),\n\tvuln_title: vulnDict[escapeHtml(req.params.vuln)],\n\tvuln_scenario: escapeHtml(req.params.vuln) + '/scenario',\n\tvuln_description: escapeHtml(req.params.vuln) + '/description',\n\tvuln_reference: escapeHtml(req.params.vuln) + '/reference',\n\tvulnerabilities:vulnDict\n}, function (err, html) {\n\tif (err) {\n\t\tconsole.log(err)\n\t\tres.status(404).send('404')\n\t} else {\n\t\tres.send(html)\n\t}\n})\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Express.js\n- escape-html\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "9dd77efa-9225-3872-a5ca-87b17ddcb5cd",
              "name": "Direct Writing to Response Object May Lead to XSS Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Scripting (XSS) is a type of injection security vulnerability typically found in web applications. XSS enables attackers to inject malicious scripts into web pages viewed by other users. A direct writing to response object vulnerability occurs when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript.\n\nIn the context of JavaScript programming, if you directly write user input to the response object, it may lead to an XSS vulnerability. For example, if you use `res.send(html)` where `html` is a string that includes user input, an attacker could inject malicious scripts into `html`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always validate and sanitize user input. Never trust user input blindly. Use a secure method to generate HTML or JavaScript from user input. \n\n## Source Code Fix Recommendation\n\nInstead of using `res.send(html)`, use a template engine that automatically escapes user input, such as EJS or Pug. Here is an example using EJS:\n\n```javascript\nvar ejs = require('ejs');\n\n// ...\n\nvar html = ejs.render('<%= userContent %>', { userContent: userInput });\nres.send(html);\n```\n\nIn this example, `ejs.render` automatically escapes `userInput`, so it is safe to include in the response.\n\n## Library Dependencies\n\nThe code example requires the `ejs` library.\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [OWASP XSS (Cross Site Scripting) Prevention Cheat Sheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "b645aa4b-e8e1-33be-9761-d900b708a3ca",
              "name": "\"EJS Output Unescaped Vulnerability Allowing XSS Attacks\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nEJS (Embedded JavaScript) is a popular templating engine for JavaScript. It allows developers to generate HTML with plain JavaScript. However, it can be vulnerable to Cross-Site Scripting (XSS) attacks if not used properly. Specifically, the `<%- include(vuln_scenario) %>` syntax in EJS outputs unescaped HTML. This means that if `vuln_scenario` contains malicious script, it will be executed in the user's browser, leading to an XSS attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always escape user input that is rendered in the HTML. This can be done by using the `<%= %>` syntax in EJS, which outputs escaped HTML. \n\n## Source Code Fix Recommendation\n\nReplace `<%- include(vuln_scenario) %>` with `<%= include(vuln_scenario) %>`. \n\n## Library Dependencies\n\nThe code example requires the `ejs` library to execute properly.\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "e9e21afb-68e3-3247-ab33-4e782da01bc9",
              "name": "\"EJS Output Unescaped Vulnerability Allowing XSS Attacks\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nEJS (Embedded JavaScript) is a popular templating engine for JavaScript. It allows developers to generate HTML with plain JavaScript. However, it can be vulnerable to Cross-Site Scripting (XSS) attacks if not used properly. \n\nIn EJS, the `<%- %>` syntax is used to output unescaped HTML content. This means that any HTML or JavaScript code included in the variable will be executed when the page is loaded. If this variable is controlled by the user (for example, it comes from a form submission or URL parameter), an attacker could inject malicious scripts, leading to an XSS attack.\n\n## Mitigation Advice\n\nTo prevent XSS attacks, always escape user input that is included in the HTML output. In EJS, you can use the `<%= %>` syntax to output escaped HTML content. This will ensure that any HTML or JavaScript code included in the variable is displayed as plain text, not executed.\n\n## Source Code Fix Recommendation\n\nReplace the vulnerable code:\n\n```javascript\n<%- include(vuln_description) %>\n```\n\nWith the fixed code:\n\n```javascript\n<%= include(vuln_description) %>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "55c7a894-c974-3bc7-94b0-70273d620d6e",
              "name": "\"EJS Output Unescaped Vulnerability Allowing XSS Attacks\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nEJS (Embedded JavaScript) is a popular templating engine for JavaScript. It allows developers to generate HTML with plain JavaScript. However, it can be vulnerable to Cross-Site Scripting (XSS) attacks if not used properly. Specifically, the `<%- include(vuln_reference) %>` syntax in EJS outputs unescaped HTML. This means that if `vuln_reference` contains malicious script, it will be executed in the user's browser, leading to an XSS attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always escape user input that is rendered in the HTML. This can be done by using the `<%= include(vuln_reference) %>` syntax instead of `<%- include(vuln_reference) %>`. The `<%=` syntax automatically escapes HTML, preventing any scripts from being executed.\n\n## Source Code Fix Recommendation\n\nReplace:\n\n```javascript\n<%- include(vuln_reference) %>\n```\n\nwith:\n\n```javascript\n<%= include(vuln_reference) %>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "21ea3123-3174-3d79-b784-74a27a5252e9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Postgresql Server Vulnerability to MITN Attacks due to Disabled TLS and Sequelize's Non-Enforcement of TLS\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "config/db.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 18,
                  "endLine": 8,
                  "endColumn": 2,
                  "snippet": {
                    "text": "module.exports = {\n  username: process.env.MYSQL_USER,\n  password: process.env.MYSQL_PASSWORD,\n  database: process.env.MYSQL_DATABASE,\n  host: process.env.MYSQL_HOST || 'mysql-db',\n  port: process.env.MYSQL_PORT || 3306,\n  dialect: 'mysql'\n}"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "18d42c0c0a3fd276b16c0ddc21cf987b591e2aff983815a6d35caa59e1f7545e",
            "glog-pfp-ruleFileCode/v1": "ec8b5d556822a64dc790d948eb569e9f826c707ed332fe5e8352d56b79ceb90e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ec8b5d556822a64dc790d948eb569e9f826c707ed332fe5e8352d56b79ceb90e"
          },
          "properties": {}
        },
        {
          "ruleId": "9e7f935e-1419-32f9-a5a8-faa28a812b45",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unvalidated User-Supplied URL Redirection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 188,
                  "startColumn": 16,
                  "endLine": 188,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\t\tres.redirect(req.query.url)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7f4ab984071a8244b8127951728d776f45cfba783aa9399325a2f442211f9d5f",
            "glog-pfp-ruleFileCode/v1": "3c1b5d011d0b9327e6ea70021b2a168489dfaac8037e7b63248dd618591616c8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3c1b5d011d0b9327e6ea70021b2a168489dfaac8037e7b63248dd618591616c8"
          },
          "properties": {}
        },
        {
          "ruleId": "78935dac-7999-370f-871a-537b887d7db3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Validate user input before using in shell commands with imported child_process module."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 14,
                  "endLine": 3,
                  "endColumn": 43,
                  "snippet": {
                    "text": "const exec = require('child_process').exec;"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "abde2a07997b073144a245b5849a9aa2988b874034275368e20601117948dcd2",
            "glog-pfp-ruleFileCode/v1": "52e56ba6871681843d646d73e95b5c0967d96a4e1be859078e7e87ad6488e884"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "52e56ba6871681843d646d73e95b5c0967d96a4e1be859078e7e87ad6488e884"
          },
          "properties": {}
        },
        {
          "ruleId": "84b854a1-f34b-311e-ba56-c80d48d54711",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential SQL Injection Vulnerability Detected in Sequelize Statement"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 21,
                  "endLine": 11,
                  "endColumn": 26,
                  "snippet": {
                    "text": "\tdb.sequelize.query(query, {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "42398eb78168e98670087eae0e8695623926c8b2e10078775df0b1cc1ee3f3c1",
            "glog-pfp-ruleFileCode/v1": "87b73a15a053cbcad5a4c2ccd78d9d10e252a7a26519db3888b5d2918e8ec399"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "87b73a15a053cbcad5a4c2ccd78d9d10e252a7a26519db3888b5d2918e8ec399"
          },
          "properties": {}
        },
        {
          "ruleId": "3b9b1a65-6df9-34c9-865c-92e11c2bd3f6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Remote Code Execution Vulnerability via Object Deserialization in serialize.unserialize Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 18,
                  "endLine": 218,
                  "endColumn": 81,
                  "snippet": {
                    "text": "\t\tvar products = serialize.unserialize(req.files.products.data.toString('utf8'))"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "19ca046e636ab9b91b643cee55596e145d0bb265b23cf4b159058965b1a59631",
            "glog-pfp-ruleFileCode/v1": "2694d78e333e86293e2ad230603d47ff2fc76d9837c4c6339fcc11b47ddfe9f1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2694d78e333e86293e2ad230603d47ff2fc76d9837c4c6339fcc11b47ddfe9f1"
          },
          "properties": {}
        },
        {
          "ruleId": "fd7234c9-f60f-32b7-86c2-9d3be0e45876",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"XML Parsing Library Found: Disable External Entity Resolution to Avoid XXE Attacks\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 16,
                  "endLine": 5,
                  "endColumn": 35,
                  "snippet": {
                    "text": "var libxmljs = require(\"libxmljs\");"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "35ca405e2b602d276a80f54dfee0bedd65c9b289ae9fbb8fee232202ffa70771",
            "glog-pfp-ruleFileCode/v1": "9b057744b126584e6bb10052a0411538274d1a964597897754ebc9ba040e5b24"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9b057744b126584e6bb10052a0411538274d1a964597897754ebc9ba040e5b24"
          },
          "properties": {}
        },
        {
          "ruleId": "1b1c4619-f040-3f90-9111-3ca724783e40",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential XSS Vulnerability from User-Controlled Data in HTML String\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 2,
                  "endLine": 10,
                  "endColumn": 78,
                  "snippet": {
                    "text": "\tvar query = \"SELECT name,id FROM Users WHERE login='\" + req.body.login + \"'\";"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "b32668493e03925996444b92fb90d5cde9dc44debd198f9800907690b28cf011",
            "glog-pfp-ruleFileCode/v1": "7e5bf8d25eec76ffb8d5ff898d3fd4aa3ed6a7c1b7c046c9c58010d6955d84ad"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7e5bf8d25eec76ffb8d5ff898d3fd4aa3ed6a7c1b7c046c9c58010d6955d84ad"
          },
          "properties": {}
        },
        {
          "ruleId": "c9476c0e-2a36-30ee-9141-e9d85491bb1a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detected Vulnerability in node-serialize Library Allowing Arbitrary Code Execution\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 17,
                  "endLine": 6,
                  "endColumn": 42,
                  "snippet": {
                    "text": "var serialize = require(\"node-serialize\")"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "34b7748288889febaac2b2b37d68336d55da8b77ed3f3eee13a7be52cf685b56",
            "glog-pfp-ruleFileCode/v1": "ad2af618a441ea8a3639e5a89a8937cec04ea74cfec92bbea1ac0b6c042b4906"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ad2af618a441ea8a3639e5a89a8937cec04ea74cfec92bbea1ac0b6c042b4906"
          },
          "properties": {}
        },
        {
          "ruleId": "af01a7ee-caac-33b0-a917-bfcfb3bce866",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Default Session Cookie Name Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "server.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 9,
                  "endLine": 28,
                  "endColumn": 3,
                  "snippet": {
                    "text": "app.use(session({\n  secret: 'keyboard cat',\n  resave: true,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}))"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ce69d2a7144ea24780ebefb0c1d53009b4b8f096808c202427ea7f2041b69b5c",
            "glog-pfp-ruleFileCode/v1": "d21428b5890bf74121f88ea5d0dc24ff6cf37e815752d7022165f97561f53cd6"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "d21428b5890bf74121f88ea5d0dc24ff6cf37e815752d7022165f97561f53cd6"
          },
          "properties": {}
        },
        {
          "ruleId": "f9220330-3239-30f0-bb86-58261d761080",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Libxml library's `noent` attribute set to `true` can lead to XXE vulnerabilities; recommended to set `noent` to `false` for protection.\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 235,
                  "startColumn": 42,
                  "endLine": 235,
                  "endColumn": 82,
                  "snippet": {
                    "text": "\t\tvar products = libxmljs.parseXmlString(req.files.products.data.toString('utf8'), {noent:true,noblanks:true})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "506d20d987043b34075880eda1b63471d7f1074d3ac7e003bcefc28ade497ce1",
            "glog-pfp-ruleFileCode/v1": "685ff32d21e97f81a6e7d48f0e43156a4b587aece4b9c62be0452da817ed68cc"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "685ff32d21e97f81a6e7d48f0e43156a4b587aece4b9c62be0452da817ed68cc"
          },
          "properties": {}
        },
        {
          "ruleId": "bab5710e-f80a-3d06-a815-795f80c5ba2a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Undetected CSRF Middleware in Your Express Application\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "server.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 5,
                  "endLine": 11,
                  "endColumn": 20,
                  "snippet": {
                    "text": "var app = express()"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c9bada67aa30b2f4eef499ae0ca4472c5112206f8b1f915f95e31c71920cec53",
            "glog-pfp-ruleFileCode/v1": "8f394d39a3ece33e72976fb1dd36c31432fd44642281eee517d4e079100167cc"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8f394d39a3ece33e72976fb1dd36c31432fd44642281eee517d4e079100167cc"
          },
          "properties": {}
        },
        {
          "ruleId": "055908f0-60ec-34e2-99d7-df61704e3569",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential Path Traversal Vulnerability Detected in `path.join` or `path.resolve` Function Due to Unsanitized User Input"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "models/index.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 55,
                  "endLine": 43,
                  "endColumn": 59,
                  "snippet": {
                    "text": "    var model = sequelize.import(path.join(__dirname, file));"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2671bcbc7e8881ce5c1529fe88dd891e4cbac87e364e04e3a05c2e963d30d822",
            "glog-pfp-ruleFileCode/v1": "27e83a190480a1c312ee9a23c21e82a9624a93f28f30257982d4be2e28bef2f4"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "27e83a190480a1c312ee9a23c21e82a9624a93f28f30257982d4be2e28bef2f4"
          },
          "properties": {}
        },
        {
          "ruleId": "0960e248-84d3-3502-bcd0-541e59f5ebba",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "SQL Injection Risk from Untrusted Input and Raw SQL Query Concatenation"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 2,
                  "endLine": 35,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tvar query = \"SELECT name,id FROM Users WHERE login='\" + req.body.login + \"'\";\n\tdb.sequelize.query(query, {\n\t\tmodel: db.User\n\t}).then(user => {\n\t\tif (user.length) {\n\t\t\tvar output = {\n\t\t\t\tuser: {\n\t\t\t\t\tname: user[0].name,\n\t\t\t\t\tid: user[0].id\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.render('app/usersearch', {\n\t\t\t\toutput: output\n\t\t\t})\n\t\t} else {\n\t\t\treq.flash('warning', 'User not found')\n\t\t\tres.render('app/usersearch', {\n\t\t\t\toutput: null\n\t\t\t})\n\t\t}\n\t}).catch(err => {\n\t\treq.flash('danger', 'Internal Error')\n\t\tres.render('app/usersearch', {\n\t\t\toutput: null\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1085e92bf69b313df40ac8e2e1a276eec8450da2d9485c79ec8d712781dd948a",
            "glog-pfp-ruleFileCode/v1": "5d54b6e7f38b5e6f22b7b077ffbefaa28ebd245c2076a41e5fa35839f111e210"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "5d54b6e7f38b5e6f22b7b077ffbefaa28ebd245c2076a41e5fa35839f111e210"
          },
          "properties": {}
        },
        {
          "ruleId": "31813b77-cfad-3bb8-8371-b438a70a3e1b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 2,
                  "endLine": 30,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.sequelize.query(query, {\n\t\tmodel: db.User\n\t}).then(user => {\n\t\tif (user.length) {\n\t\t\tvar output = {\n\t\t\t\tuser: {\n\t\t\t\t\tname: user[0].name,\n\t\t\t\t\tid: user[0].id\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.render('app/usersearch', {\n\t\t\t\toutput: output\n\t\t\t})\n\t\t} else {\n\t\t\treq.flash('warning', 'User not found')\n\t\t\tres.render('app/usersearch', {\n\t\t\t\toutput: null\n\t\t\t})\n\t\t}\n\t}).catch(err => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c5b64d1e95afdc96ec94817996ed9fa4919913e89c2ea399839d1df707c6f6ba",
            "glog-pfp-ruleFileCode/v1": "f9fef2ccfc298a4c54522af0242213e466f561d56f874dbfba068ddaadd44679"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f9fef2ccfc298a4c54522af0242213e466f561d56f874dbfba068ddaadd44679"
          },
          "properties": {}
        },
        {
          "ruleId": "a46d83fc-ded8-3469-8316-e0528591d6d3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 71,
                  "endLine": 20,
                  "endColumn": 95,
                  "snippet": {
                    "text": "                Listing products with <strong>search query: </strong> <%- output.searchTerm %>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "993cce01512140422849249323195d439a005b4b58a35d471011c01600017e9a",
            "glog-pfp-ruleFileCode/v1": "0e9cccdc992c79010607886b7d65d2e97cdb61884eb2eee736f32b59bb35abd5"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0e9cccdc992c79010607886b7d65d2e97cdb61884eb2eee736f32b59bb35abd5"
          },
          "properties": {}
        },
        {
          "ruleId": "d20ba9e2-94ee-370c-9227-db01ee13e9a0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Hard-Coded Credential Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "server.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 3,
                  "endLine": 24,
                  "endColumn": 25,
                  "snippet": {
                    "text": "  secret: 'keyboard cat',"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "fc790f145993a88de1a5aa0e57223726c800a5a7e7b13118b6a333d986b0f238",
            "glog-pfp-ruleFileCode/v1": "c336c57472dc474291c203356374d2853f35243da865c207e215cf156512c387"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c336c57472dc474291c203356374d2853f35243da865c207e215cf156512c387"
          },
          "properties": {}
        },
        {
          "ruleId": "90408b14-a210-379b-a93e-9fa7a1965540",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 21,
                  "endLine": 49,
                  "endColumn": 49,
                  "snippet": {
                    "text": "                <td><%- output.products[i].id %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "4599dd340bf56d897d52f230329a557b79cb97e86a3f98364657481c8f35c407",
            "glog-pfp-ruleFileCode/v1": "3123ded679437e1954d4b7f0a1acff93f7c33600ccabe1ba71a78adfc840e081"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3123ded679437e1954d4b7f0a1acff93f7c33600ccabe1ba71a78adfc840e081"
          },
          "properties": {}
        },
        {
          "ruleId": "6b3d767a-cfe7-3b6c-87d8-4ff57074985f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Command Injection Vulnerability through User Input Concatenation\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 2,
                  "endLine": 44,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\texec('ping -c 2 ' + req.body.address, function (err, stdout, stderr) {\n\t\toutput = stdout + stderr\n\t\tres.render('app/ping', {\n\t\t\toutput: output\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c836ff7ece7e99e795ec649e9e58181c3588075e173dfdbe9ae7c1a22a4a3918",
            "glog-pfp-ruleFileCode/v1": "b7a24f6ff425db4bbceebd025a0f58b4f690c00485f0ff5bb94f3b1368856e86"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "b7a24f6ff425db4bbceebd025a0f58b4f690c00485f0ff5bb94f3b1368856e86"
          },
          "properties": {}
        },
        {
          "ruleId": "266a70bf-e91c-31bb-8b33-7be81335992b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 21,
                  "endLine": 50,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                <td><%- output.products[i].name %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e11211defbe7ebd1814bc865b8d48d6499771aff0028cbd96c689144ce449e63",
            "glog-pfp-ruleFileCode/v1": "280392f0b9a5a25c1b8b8f8dc3b63ae648666f8e0fa02d10d2ddc1fce8eaedeb"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "280392f0b9a5a25c1b8b8f8dc3b63ae648666f8e0fa02d10d2ddc1fce8eaedeb"
          },
          "properties": {}
        },
        {
          "ruleId": "2a87e4aa-7bb1-34b0-9997-53cf7be00f72",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 21,
                  "endLine": 51,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                <td><%- output.products[i].code %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f68139076127b27a901c42af24d89e06e61541388985b8b0dad6824951912fa3",
            "glog-pfp-ruleFileCode/v1": "3525ed1ff18117443a2d2c3ff0c386dbf5000b2c4f8a1ec31a81cbf06ac9d92b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3525ed1ff18117443a2d2c3ff0c386dbf5000b2c4f8a1ec31a81cbf06ac9d92b"
          },
          "properties": {}
        },
        {
          "ruleId": "a8c344fb-e0b9-3bd0-beba-bc74b30a9708",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 21,
                  "endLine": 52,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                <td><%- output.products[i].tags %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1afa7e9f36e186fd802d95bbc8636c5ae0c00de7c39a40d00e4e0c03c31b2e5d",
            "glog-pfp-ruleFileCode/v1": "33c53a6479372986ae56ac256ea71bae7bfa25af72411647756a8b80c8f51c9a"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "33c53a6479372986ae56ac256ea71bae7bfa25af72411647756a8b80c8f51c9a"
          },
          "properties": {}
        },
        {
          "ruleId": "45081c46-bcda-384a-96d1-9d48f46fb46a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 21,
                  "endLine": 53,
                  "endColumn": 58,
                  "snippet": {
                    "text": "                <td><%- output.products[i].description %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "10ff96811314b638ff52e3b999b576d6a645f52fcbc1cfd0a329e3e99acfe70b",
            "glog-pfp-ruleFileCode/v1": "02e3cc1569b79b040e42aaa8412933d32fbd2ba308b25d1f1f73470405180e24"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "02e3cc1569b79b040e42aaa8412933d32fbd2ba308b25d1f1f73470405180e24"
          },
          "properties": {}
        },
        {
          "ruleId": "7e2b05b3-38c9-35ad-9929-bf922d0085db",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 2,
                  "endLine": 48,
                  "endColumn": 22,
                  "snippet": {
                    "text": "\tdb.Product.findAll().then(products => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "caf6d4570f6b157334a62b557dfd5df1ea4fee4dd1b463172f98cde070607721",
            "glog-pfp-ruleFileCode/v1": "cbdf47c63de4f63e7b58d975a1e21b95916c9a7c45cf594cd5b37a15151329e1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "cbdf47c63de4f63e7b58d975a1e21b95916c9a7c45cf594cd5b37a15151329e1"
          },
          "properties": {}
        },
        {
          "ruleId": "c8d00ddc-cb2f-3386-8938-1060a8e7a487",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 2,
                  "endLine": 55,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.Product.findAll().then(products => {\n\t\toutput = {\n\t\t\tproducts: products\n\t\t}\n\t\tres.render('app/products', {\n\t\t\toutput: output\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "73310be0d62f3dfc78d1ff16fcb864e4b104e73b4c67aacf6850f14a716b919b",
            "glog-pfp-ruleFileCode/v1": "f7475cc8c516f142e3f7b3bfb85bc6429b47d254afcce12486e6e00f11d42473"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f7475cc8c516f142e3f7b3bfb85bc6429b47d254afcce12486e6e00f11d42473"
          },
          "properties": {}
        },
        {
          "ruleId": "caa78969-106f-30a0-815f-8634d1d554c0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 2,
                  "endLine": 65,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.Product.findAll({\n\t\twhere: {\n\t\t\tname: {\n\t\t\t\t[Op.like]: '%' + req.body.name + '%'\n\t\t\t}\n\t\t}\n\t}).then(products => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "9f759e30d4eeeacf1d39668182e6cc6848cc0a6146914b736979c912b91ed97c",
            "glog-pfp-ruleFileCode/v1": "0549d55724c181763ab5318ed115164d719bff75d6b5fe8b76241f07213cc455"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0549d55724c181763ab5318ed115164d719bff75d6b5fe8b76241f07213cc455"
          },
          "properties": {}
        },
        {
          "ruleId": "d956d5d7-fa6d-32d3-9cd0-0b60c5231067",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "XSS Vulnerability from User-Controlled Data in HTML String"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 2,
                  "endLine": 73,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.Product.findAll({\n\t\twhere: {\n\t\t\tname: {\n\t\t\t\t[Op.like]: '%' + req.body.name + '%'\n\t\t\t}\n\t\t}\n\t}).then(products => {\n\t\toutput = {\n\t\t\tproducts: products,\n\t\t\tsearchTerm: req.body.name\n\t\t}\n\t\tres.render('app/products', {\n\t\t\toutput: output\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "bfa71a8174f21d74aa29f178623cfeb94b3b482472d0d439940538a0671362d6",
            "glog-pfp-ruleFileCode/v1": "20d2d5415d7345438ef551832b5378d123b27b512c818cf5e44a418b55a0bd9e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "20d2d5415d7345438ef551832b5378d123b27b512c818cf5e44a418b55a0bd9e"
          },
          "properties": {}
        },
        {
          "ruleId": "0e6fc9e5-03de-37aa-af56-1faa4c6e245a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 3,
                  "endLine": 89,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.Product.find({\n\t\t\twhere: {\n\t\t\t\t'id': req.query.id\n\t\t\t}\n\t\t}).then(product => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "244f1bd534f117bd3919e03ca082d002d1c269c5c8b34f7047798105d0b2b395",
            "glog-pfp-ruleFileCode/v1": "fcc624b36569d012b9a6eef2003473a1b6efc7f61f61dcf94e2d4d638fd69bfd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "fcc624b36569d012b9a6eef2003473a1b6efc7f61f61dcf94e2d4d638fd69bfd"
          },
          "properties": {}
        },
        {
          "ruleId": "62bc3e5d-aa43-36a8-9c56-36406f37f48a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 2,
                  "endLine": 111,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.Product.find({\n\t\twhere: {\n\t\t\t'id': req.body.id\n\t\t}\n\t}).then(product => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e539eca08d5e8acd6c37edaf7f662a137353aa82d0cebf4336ec53015204c0b4",
            "glog-pfp-ruleFileCode/v1": "6f70bb3095b5dbdf1ab64d1eb803299e688d24b057ef355cee89cfc8ebf960a2"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "6f70bb3095b5dbdf1ab64d1eb803299e688d24b057ef355cee89cfc8ebf960a2"
          },
          "properties": {}
        },
        {
          "ruleId": "3f9d0612-751a-37dd-91b8-d38a6efa8402",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 3,
                  "endLine": 99,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.Product.find({\n\t\t\twhere: {\n\t\t\t\t'id': req.query.id\n\t\t\t}\n\t\t}).then(product => {\n\t\t\tif (!product) {\n\t\t\t\tproduct = {}\n\t\t\t}\n\t\t\toutput = {\n\t\t\t\tproduct: product\n\t\t\t}\n\t\t\tres.render('app/modifyproduct', {\n\t\t\t\toutput: output\n\t\t\t})\n\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "a54a8c352c2e2d3ae6622d66d25fa24e36609c89630a6bec97f0c91c16836faf",
            "glog-pfp-ruleFileCode/v1": "a6c89ad6c1d971385e6deffcc4d7e1729e59bb809993223512e2081d2789bbfa"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "a6c89ad6c1d971385e6deffcc4d7e1729e59bb809993223512e2081d2789bbfa"
          },
          "properties": {}
        },
        {
          "ruleId": "2f5df063-de60-3c21-a023-00eed651128b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 2,
                  "endLine": 133,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.Product.find({\n\t\twhere: {\n\t\t\t'id': req.body.id\n\t\t}\n\t}).then(product => {\n\t\tif (!product) {\n\t\t\tproduct = new db.Product()\n\t\t}\n\t\tproduct.code = req.body.code\n\t\tproduct.name = req.body.name\n\t\tproduct.description = req.body.description\n\t\tproduct.tags = req.body.tags\n\t\tproduct.save().then(p => {\n\t\t\tif (p) {\n\t\t\t\treq.flash('success', 'Product added/modified!')\n\t\t\t\tres.redirect('/app/products')\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\toutput = {\n\t\t\t\tproduct: product\n\t\t\t}\n\t\t\treq.flash('danger',err)\n\t\t\tres.render('app/modifyproduct', {\n\t\t\t\toutput: output\n\t\t\t})\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e8c0c58eac9902631557cf2c5170910fd6db71d0dc4f3755917442264ac5e132",
            "glog-pfp-ruleFileCode/v1": "6790b2ce7b934455801fe75f8871c24d9ea6f3acc8d850451906c5302381d367"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "6790b2ce7b934455801fe75f8871c24d9ea6f3acc8d850451906c5302381d367"
          },
          "properties": {}
        },
        {
          "ruleId": "ccc3f7d3-17f7-3c2e-a1bf-d4b3c5003260",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 2,
                  "endLine": 149,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.User.find({\n\t\twhere: {\n\t\t\t'id': req.body.id\n\t\t}\t\t\n\t}).then(user =>{"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "cd7f31aba4c9b49ea9f41d97d7baa29165d4189d8fb2db32689f50ffbe3620de",
            "glog-pfp-ruleFileCode/v1": "d45ec6e43b1cf3982921b803fe90ebd8820d669ff4ff76584e5949c9d7381625"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "d45ec6e43b1cf3982921b803fe90ebd8820d669ff4ff76584e5949c9d7381625"
          },
          "properties": {}
        },
        {
          "ruleId": "15724e00-e71c-3b1d-906e-22bafe0e35de",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 2,
                  "endLine": 183,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.User.find({\n\t\twhere: {\n\t\t\t'id': req.body.id\n\t\t}\t\t\n\t}).then(user =>{\n\t\tif(req.body.password.length>0){\n\t\t\tif(req.body.password.length>0){\n\t\t\t\tif (req.body.password == req.body.cpassword) {\n\t\t\t\t\tuser.password = bCrypt.hashSync(req.body.password, bCrypt.genSaltSync(10), null)\n\t\t\t\t}else{\n\t\t\t\t\treq.flash('warning', 'Passwords dont match')\n\t\t\t\t\tres.render('app/useredit', {\n\t\t\t\t\t\tuserId: req.user.id,\n\t\t\t\t\t\tuserEmail: req.user.email,\n\t\t\t\t\t\tuserName: req.user.name,\n\t\t\t\t\t})\n\t\t\t\t\treturn\t\t\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treq.flash('warning', 'Invalid Password')\n\t\t\t\tres.render('app/useredit', {\n\t\t\t\t\tuserId: req.user.id,\n\t\t\t\t\tuserEmail: req.user.email,\n\t\t\t\t\tuserName: req.user.name,\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tuser.email = req.body.email\n\t\tuser.name = req.body.name\n\t\tuser.save().then(function () {\n\t\t\treq.flash('success',\"Updated successfully\")\n\t\t\tres.render('app/useredit', {\n\t\t\t\tuserId: req.body.id,\n\t\t\t\tuserEmail: req.body.email,\n\t\t\t\tuserName: req.body.name,\n\t\t\t})\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7ce8e7788adeffef3664f2e40cd75cd71f9e5a9ae3e46b28542c6eacec0ab769",
            "glog-pfp-ruleFileCode/v1": "f3d010e7da0e81c1be5bb2f494c75bce202bceb1c718f854b5165cc767272a04"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f3d010e7da0e81c1be5bb2f494c75bce202bceb1c718f854b5165cc767272a04"
          },
          "properties": {}
        },
        {
          "ruleId": "de1c00f3-1236-30a1-858c-433ce6f12886",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Code Injection Vulnerability Detected\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 197,
                  "startColumn": 12,
                  "endLine": 197,
                  "endColumn": 37,
                  "snippet": {
                    "text": "\t\t\toutput: mathjs.eval(req.body.eqn)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2f2e58053cbb67ba42ac007cae9978f34f32cba101be5d31d28d20d31c210bfd",
            "glog-pfp-ruleFileCode/v1": "04f41ca4d0876366afc8cf1edad5f771d4b67884aabb035913e696943ea3320c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "04f41ca4d0876366afc8cf1edad5f771d4b67884aabb035913e696943ea3320c"
          },
          "properties": {}
        },
        {
          "ruleId": "1e4caf67-5bfb-3038-9006-891aefedc48b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unfiltered Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 2,
                  "endLine": 207,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\tdb.User.findAll({}).then(users => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "fc7eff1cac5e8f14f3bb944c0af52bec5324c25717b746b5de42c14069171821",
            "glog-pfp-ruleFileCode/v1": "c68d9a4cfec36cf72f2dca9411b85b914512cb16a5795afd2074abd864d06442"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c68d9a4cfec36cf72f2dca9411b85b914512cb16a5795afd2074abd864d06442"
          },
          "properties": {}
        },
        {
          "ruleId": "58d74204-e872-36aa-836d-ab10502a5418",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Insecure Cryptographic Hash Identified: MD5, SHA1 Inadequate for Security; bcrypt, scrypt, Argon2 Recommended for Passwords; SHA-256+ Suggested for Integrity Checks."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 11,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "var md5 = require('md5')"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "26cb90b1bfe6e22e5adba0997ee91178f76882ac7ec1db32db7721df0a507796",
            "glog-pfp-ruleFileCode/v1": "0c1af6346e1a198a566ee247b60628a88da636516243fff1e89c05c2ac0e9715"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0c1af6346e1a198a566ee247b60628a88da636516243fff1e89c05c2ac0e9715"
          },
          "properties": {}
        },
        {
          "ruleId": "ce987a29-92e0-3e8b-aff6-d07dc2295ee9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unfiltered Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 3,
                  "endLine": 25,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.User.find({\n\t\t\twhere: {\n\t\t\t\t'login': req.body.login\n\t\t\t}\n\t\t}).then(user => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "9043b1d984a1019c3e7303bc7c5411099f5c0715205f13a85a0e25be36279848",
            "glog-pfp-ruleFileCode/v1": "c40bbdd5a62dd677ebb961ca1df3ad90ea1911e18a40be0bca87fdba66dc29a1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c40bbdd5a62dd677ebb961ca1df3ad90ea1911e18a40be0bca87fdba66dc29a1"
          },
          "properties": {}
        },
        {
          "ruleId": "c5680213-67cb-3707-9b6c-1ce025528422",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 3,
                  "endLine": 34,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.User.find({\n\t\t\twhere: {\n\t\t\t\t'login': req.body.login\n\t\t\t}\n\t\t}).then(user => {\n\t\t\tif (user) {\n\t\t\t\t// Send reset link via email happens here\n\t\t\t\treq.flash('info', 'Check email for reset link')\n\t\t\t\tres.redirect('/login')\n\t\t\t} else {\n\t\t\t\treq.flash('danger', \"Invalid login username\")\n\t\t\t\tres.redirect('/forgotpw')\n\t\t\t}\n\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "18044355b1f701cdc533935d3c8f64ae8778ecabddb2d16eb05daea292c65250",
            "glog-pfp-ruleFileCode/v1": "7b84b6a0ae6ac2c8b009b5e41413a8fab62c1d453288032faf9a803e775bb9e1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7b84b6a0ae6ac2c8b009b5e41413a8fab62c1d453288032faf9a803e775bb9e1"
          },
          "properties": {}
        },
        {
          "ruleId": "7b866c05-60b3-3d40-8e2b-070af8617634",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 3,
                  "endLine": 47,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.User.find({\n\t\t\twhere: {\n\t\t\t\t'login': req.query.login\n\t\t\t}\n\t\t}).then(user => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5907561c300b28b36bdc892914107701ff615f056b40ee9a13c086fe5fcc51cd",
            "glog-pfp-ruleFileCode/v1": "0f4a199e1ce3bf5b437c7f7e893a7b7240ac7a150d5450d95a95b3f1012751f7"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0f4a199e1ce3bf5b437c7f7e893a7b7240ac7a150d5450d95a95b3f1012751f7"
          },
          "properties": {}
        },
        {
          "ruleId": "a7464f96-d4d8-381b-aa8b-37c31c0eb135",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 3,
                  "endLine": 62,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.User.find({\n\t\t\twhere: {\n\t\t\t\t'login': req.query.login\n\t\t\t}\n\t\t}).then(user => {\n\t\t\tif (user) {\n\t\t\t\tif (req.query.token == md5(req.query.login)) {\n\t\t\t\t\tres.render('resetpw', {\n\t\t\t\t\t\tlogin: req.query.login,\n\t\t\t\t\t\ttoken: req.query.token\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\treq.flash('danger', \"Invalid reset token\")\n\t\t\t\t\tres.redirect('/forgotpw')\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treq.flash('danger', \"Invalid login username\")\n\t\t\t\tres.redirect('/forgotpw')\n\t\t\t}\n\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ba46914313d3cdde3a6cf3a8251c9de85cda981d9cdf78f3c12c300aa3aef2b2",
            "glog-pfp-ruleFileCode/v1": "7b4a39325450bfa889052351abe3f48ae43c0f95cb7a09c32fdd4d2c6f0c7b03"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7b4a39325450bfa889052351abe3f48ae43c0f95cb7a09c32fdd4d2c6f0c7b03"
          },
          "properties": {}
        },
        {
          "ruleId": "5640a9f3-0a6b-31b1-89b7-afa1ae4a5298",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "MD5 User-Controlled Input Leads to Guessable Tokens Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 8,
                  "endLine": 49,
                  "endColumn": 49,
                  "snippet": {
                    "text": "\t\t\t\tif (req.query.token == md5(req.query.login)) {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ba7fdd0cfb781e59cbd3f0c29846faa583bff6b69235e115a57c87ce82ec506d",
            "glog-pfp-ruleFileCode/v1": "1cf638db5d0691d600f533a001520e9459dc063317755b9a80a36ca3361b6693"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "1cf638db5d0691d600f533a001520e9459dc063317755b9a80a36ca3361b6693"
          },
          "properties": {}
        },
        {
          "ruleId": "83ca2a00-6d50-3d3c-b58c-b3ebbaadfd82",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unfiltered Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 4,
                  "endLine": 76,
                  "endColumn": 6,
                  "snippet": {
                    "text": "\t\t\tdb.User.find({\n\t\t\t\twhere: {\n\t\t\t\t\t'login': req.body.login\n\t\t\t\t}\n\t\t\t}).then(user => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "cc03baa18480cc562095135117fc601ca94f761037a179794ae2d07224d681f5",
            "glog-pfp-ruleFileCode/v1": "f33953a98bac0e1a2f0fd016e70f086d816ad181e41c960e3c34c7a86baed678"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f33953a98bac0e1a2f0fd016e70f086d816ad181e41c960e3c34c7a86baed678"
          },
          "properties": {}
        },
        {
          "ruleId": "cf96834b-e589-3399-b7af-68f942a5a2e7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 4,
                  "endLine": 92,
                  "endColumn": 6,
                  "snippet": {
                    "text": "\t\t\tdb.User.find({\n\t\t\t\twhere: {\n\t\t\t\t\t'login': req.body.login\n\t\t\t\t}\n\t\t\t}).then(user => {\n\t\t\t\tif (user) {\n\t\t\t\t\tif (req.body.token == md5(req.body.login)) {\n\t\t\t\t\t\tuser.password = bCrypt.hashSync(req.body.password, bCrypt.genSaltSync(10), null)\n\t\t\t\t\t\tuser.save().then(function () {\n\t\t\t\t\t\t\treq.flash('success', \"Passowrd successfully reset\")\n\t\t\t\t\t\t\tres.redirect('/login')\n\t\t\t\t\t\t})\n\t\t\t\t\t} else {\n\t\t\t\t\t\treq.flash('danger', \"Invalid reset token\")\n\t\t\t\t\t\tres.redirect('/forgotpw')\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treq.flash('danger', \"Invalid login username\")\n\t\t\t\t\tres.redirect('/forgotpw')\n\t\t\t\t}\n\t\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "078c75d5164b2b059aa88af3a10c3037bfe3349724377deff793a2bd4cc2a04e",
            "glog-pfp-ruleFileCode/v1": "6cb0630bf849ab113c588d225bea2b0994d46f3b25ff2add9340df85ff11df50"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "6cb0630bf849ab113c588d225bea2b0994d46f3b25ff2add9340df85ff11df50"
          },
          "properties": {}
        },
        {
          "ruleId": "5f90b615-344e-3cf8-88ec-191e098a501e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "MD5 User-Controlled Input Predictability Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 9,
                  "endLine": 78,
                  "endColumn": 48,
                  "snippet": {
                    "text": "\t\t\t\t\tif (req.body.token == md5(req.body.login)) {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "774620ccd41d306e43f233186ef7df22178cea17feec7bb83ac02e00b46d4ebf",
            "glog-pfp-ruleFileCode/v1": "4ebc43ee0775a0b875fbf953875147258bccacfab378cb077ae974be93393dc8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "4ebc43ee0775a0b875fbf953875147258bccacfab378cb077ae974be93393dc8"
          },
          "properties": {}
        },
        {
          "ruleId": "9225247f-64c7-3daa-84ac-d02dd219a622",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/passport.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 9,
                  "endLine": 24,
                  "endColumn": 11,
                  "snippet": {
                    "text": "        db.User.findOne({\n            where: {\n                'id': uid\n            }\n        }).then(function (user) {\n            if (user) {\n                done(null, user);\n            } else {\n                done(null, false)\n            }\n\n        })"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7cf4a583e84a3efbd379bc6b709268c17310300596564082da19b165c86bd399",
            "glog-pfp-ruleFileCode/v1": "2728e751ad73d87f91181ee1b27e39a08e04ff72bbfd1c97ca2463de4845fa22"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2728e751ad73d87f91181ee1b27e39a08e04ff72bbfd1c97ca2463de4845fa22"
          },
          "properties": {}
        },
        {
          "ruleId": "866313ba-f531-3b3a-acc7-36dbe347579d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/passport.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 13,
                  "endLine": 43,
                  "endColumn": 15,
                  "snippet": {
                    "text": "            db.User.findOne({\n                where: {\n                    'login': username\n                }\n            }).then(function (user) {\n                if (!user) {\n                    return done(null, false, req.flash('danger', 'Invalid Credentials'))\n                }\n                if (!isValidPassword(user, password)) {\n                    return done(null, false, req.flash('danger', 'Invalid Credentials'))\n                }\n                return done(null, user);\n            });"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "4a064aab7985d69f833a3bad32e45100358c930bb529d75b902ba41418c9e4a0",
            "glog-pfp-ruleFileCode/v1": "36cba2615d5ac08e075d449374cad34c78d4b753fedf82819b4d552531712eb0"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "36cba2615d5ac08e075d449374cad34c78d4b753fedf82819b4d552531712eb0"
          },
          "properties": {}
        },
        {
          "ruleId": "c2ed1196-9838-3188-9305-8e74c53a8388",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/passport.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 17,
                  "endLine": 80,
                  "endColumn": 19,
                  "snippet": {
                    "text": "                db.User.findOne({\n                    where: {\n                        'email': username\n                    }\n                }).then(function (user) {\n                    if (user) {\n                        return done(null, false, req.flash('danger', 'Account Already Exists'));\n                    } else {\n                        if (req.body.email && req.body.password && req.body.username && req.body.cpassword && req.body.name) {\n                            if (req.body.cpassword == req.body.password) {\n                                db.User.create({\n                                    email: req.body.email,\n                                    password: createHash(password),\n                                    name: req.body.name,\n                                    login: username\n                                }).then(function (user) {\n                                    return done(null, user)\n                                })\n                            } else {\n                                return done(null, false, req.flash('danger', 'Passwords dont match'));\n                            }\n                        } else {\n                            return done(null, false, req.flash('danger', 'Input field(s) missing'));\n                        }\n                    }\n                });"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "3ccecb46cc286d10ef44f2509e133fb192369adc277af27c0824a67402c77777",
            "glog-pfp-ruleFileCode/v1": "3df509f3ac364804d45f47a5bd2819310191e59c79e9f55c532e7c902b38f574"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3df509f3ac364804d45f47a5bd2819310191e59c79e9f55c532e7c902b38f574"
          },
          "properties": {}
        },
        {
          "ruleId": "f40d37bc-a799-33d2-976e-505fb388e17a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "models/index.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 1,
                  "endLine": 22,
                  "endColumn": 5,
                  "snippet": {
                    "text": "sequelize\n  .authenticate()\n  .then(function (err) {\n    console.log('Connection has been established successfully.');\n  })"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "02aefa470daaa1d7e4a675e9cf037d166824286667fe96ef13cb43f6de773d22",
            "glog-pfp-ruleFileCode/v1": "9dc09d1108f53b7c3478afa37b8468aafcb46cb50f6fe924eadb2ce0fd65eedf"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9dc09d1108f53b7c3478afa37b8468aafcb46cb50f6fe924eadb2ce0fd65eedf"
          },
          "properties": {}
        },
        {
          "ruleId": "073f2b99-5b1e-39a8-8ef2-1116fdbbfb79",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential Out-of-Destination Writing Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "models/index.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 34,
                  "endLine": 43,
                  "endColumn": 60,
                  "snippet": {
                    "text": "    var model = sequelize.import(path.join(__dirname, file));"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "179daf6e0f06b30622a34e86ea18eb4646c14c13358bca4a6f753911aacb644c",
            "glog-pfp-ruleFileCode/v1": "91b238fda8649fde2c58a7a732138da7a9a42f28d0fa6086fbedaf4053bb0904"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "91b238fda8649fde2c58a7a732138da7a9a42f28d0fa6086fbedaf4053bb0904"
          },
          "properties": {}
        },
        {
          "ruleId": "2992bbde-9c2e-361f-91b2-31865be4434c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential XSS Vulnerability from User-Controlled Data in HTML String\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "routes/main.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 3,
                  "endLine": 29,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tres.render('vulnerabilities/layout', {\n\t\t\tvuln: req.params.vuln,\n\t\t\tvuln_title: vulnDict[req.params.vuln],\n\t\t\tvuln_scenario: req.params.vuln + '/scenario',\n\t\t\tvuln_description: req.params.vuln + '/description',\n\t\t\tvuln_reference: req.params.vuln + '/reference',\n\t\t\tvulnerabilities:vulnDict\n\t\t}, function (err, html) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(err)\n\t\t\t\tres.status(404).send('404')\n\t\t\t} else {\n\t\t\t\tres.send(html)\n\t\t\t}\n\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "fa24c3e3ac8bdbf6f30ee25dccfb940d41533d143872a354fcd37156e2a9fa43",
            "glog-pfp-ruleFileCode/v1": "ee71c376aff21ac374d692dada9caf9426f950d53572a4c884b9d55f7e5f75cd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ee71c376aff21ac374d692dada9caf9426f950d53572a4c884b9d55f7e5f75cd"
          },
          "properties": {}
        },
        {
          "ruleId": "9dd77efa-9225-3872-a5ca-87b17ddcb5cd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Direct Writing to Response Object May Lead to XSS Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "routes/main.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 5,
                  "endLine": 27,
                  "endColumn": 19,
                  "snippet": {
                    "text": "\t\t\t\tres.send(html)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "6fbc57301235501f775fcabe1e168a32ec8faa20b2c27945a9de8280012bfb80",
            "glog-pfp-ruleFileCode/v1": "7f0f028e32eaf21d4080d350b1fc7f637e30f78ef12b5b02d4d518b187f4fa28"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7f0f028e32eaf21d4080d350b1fc7f637e30f78ef12b5b02d4d518b187f4fa28"
          },
          "properties": {}
        },
        {
          "ruleId": "b645aa4b-e8e1-33be-9761-d900b708a3ca",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"EJS Output Unescaped Vulnerability Allowing XSS Attacks\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/vulnerabilities/layout.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 13,
                  "endLine": 35,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            <%- include(vuln_scenario) %>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "91738070d4debc36a54617507a2c6d403a8e4a5cced26705b9edfcb6b54da014",
            "glog-pfp-ruleFileCode/v1": "21eee536736781931e0b192de852ef1c27c2c3f863be7ed141973eccc2156a89"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "21eee536736781931e0b192de852ef1c27c2c3f863be7ed141973eccc2156a89"
          },
          "properties": {}
        },
        {
          "ruleId": "e9e21afb-68e3-3247-ab33-4e782da01bc9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"EJS Output Unescaped Vulnerability Allowing XSS Attacks\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/vulnerabilities/layout.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 13,
                  "endLine": 38,
                  "endColumn": 43,
                  "snippet": {
                    "text": "            <%- include(vuln_description) %>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5524d045849950e9dd042ab36f7ab7727357e379955a332002a81ff0d51df3ef",
            "glog-pfp-ruleFileCode/v1": "ccb3d7b105b26dc2e3ba5d29f931e725ae0c1c5cb22f5101b1bf495a86e46056"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ccb3d7b105b26dc2e3ba5d29f931e725ae0c1c5cb22f5101b1bf495a86e46056"
          },
          "properties": {}
        },
        {
          "ruleId": "55c7a894-c974-3bc7-94b0-70273d620d6e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"EJS Output Unescaped Vulnerability Allowing XSS Attacks\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/vulnerabilities/layout.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 13,
                  "endLine": 41,
                  "endColumn": 41,
                  "snippet": {
                    "text": "            <%- include(vuln_reference) %>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "64d1b32612a3246fc802e592395145256c2533ba564cedee6a315cb28ea05af9",
            "glog-pfp-ruleFileCode/v1": "380cea43e4f520d801b0a71773921e2f9a4f22e2bde6e967c84665d5ae23dfe9"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "380cea43e4f520d801b0a71773921e2f9a4f22e2bde6e967c84665d5ae23dfe9"
          },
          "properties": {}
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}