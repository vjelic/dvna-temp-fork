{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "b319a673-91d8-3d13-87d2-3721942851a7",
              "name": "Doubtful Remark",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "\"Doubtful Remark\" is not a recognized vulnerability in JavaScript programming language or any other programming language. It seems like there might be a misunderstanding or miscommunication about the term. \n\nIn the context of programming, a \"remark\" is often another term for a \"comment\" - a piece of code ignored by the compiler or interpreter, used by developers to annotate and explain their code. If a \"doubtful remark\" refers to a comment that may be misleading or incorrect, this could potentially lead to confusion or mistakes in the future, but it wouldn't be a security vulnerability per se.\n\nIf you're referring to a different kind of vulnerability, please provide more details or use the commonly accepted name for the vulnerability. \n\nCommon vulnerabilities in JavaScript often include Cross-Site Scripting (XSS), Cross-Site Request Forgery (CSRF), and Server-Side JavaScript Injection. These vulnerabilities are well-documented and mitigation strategies often involve proper input validation, output encoding, and use of security headers.\n\nFor more information on JavaScript security, you can refer to the following resources:\n\n- [OWASP JavaScript Security](https://owasp.org/www-community/attacks/xss/)\n- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/)\n- [Common Weakness Enumeration (CWE)](https://cwe.mitre.org/)\n\nPlease note that these links are subject to change and may not always be accessible. Always ensure to follow best practices and stay updated with the latest security standards."
              },
              "properties": {
                "cwe": [],
                "severity": "LOW",
                "kind": "FAIL"
              }
            },
            {
              "id": "20dbfa51-beb8-3d15-99f7-f93f54a67525",
              "name": "Vulnerable Hash Algorithm",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in JavaScript occurs when a weak cryptographic hash function, such as MD5, is used for security-critical functionality. MD5 is considered to be a weak hash function as it is susceptible to hash collisions, where different inputs produce the same hash output. This can lead to various security issues such as password cracking, data integrity attacks, and other forms of data tampering.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a stronger hash function such as SHA-256 or SHA-3. These hash functions are currently considered to be secure for most purposes. Additionally, when hashing passwords, it is recommended to use a function designed for password hashing, such as bcrypt, scrypt, or Argon2.\n\n## Source Code Fix Recommendation\n\nIf you are using the `crypto` library's `createHash` function with 'md5' as the argument, replace 'md5' with 'sha256' or 'sha3'.\n\n```javascript\n// Vulnerable code\nconst crypto = require('crypto');\nconst hash = crypto.createHash('md5');\nhash.update('some data to hash');\nconsole.log(hash.digest('hex'));\n\n// Fixed code\nconst crypto = require('crypto');\nconst hash = crypto.createHash('sha256');\nhash.update('some data to hash');\nconsole.log(hash.digest('hex'));\n```\n\n## Library Dependencies\n\nThe code example requires the `crypto` library, which is a built-in module in Node.js, so no additional installation is necessary.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-327",
                    "url": "https://cwe.mitre.org/data/definitions/327.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-327"
                ]
              }
            },
            {
              "id": "78935dac-7999-370f-871a-537b887d7db3",
              "name": "Validate user input before using in shell commands with imported child_process module.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn JavaScript, the `child_process` module provides the ability to spawn child processes in a manner that is similar, but not identical, to popen(3). This can be particularly dangerous if you're executing shell commands that include unvalidated user input. This can lead to command injection vulnerabilities where an attacker can inject arbitrary commands to be executed on the server.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always validate and sanitize user input before using it in shell commands. This can be done by using regular expressions, whitelist input validation, or by using parameterized functions. Avoid using shell commands where possible and use safer alternatives like `child_process.execFile()` or `child_process.spawn()` which do not spawn a shell by default.\n\n## Source Code Fix Recommendation\n\nHere's an example of how you can fix this vulnerability:\n\n```javascript\nconst execFile = require('child_process').execFile;\n\nlet user_input = \"...\"; // User input\n\n// Validate user input here\n\nexecFile('command', [user_input], (error, stdout, stderr) => {\n  if (error) {\n    throw error;\n  }\n  console.log(stdout);\n});\n```\n\nIn this example, `execFile()` is used instead of `exec()`. The command to be executed is separated from the arguments, which prevents shell metacharacters (like semicolons and ampersands) from being interpreted.\n\n## Library Dependencies\n\nThe `child_process` module is a core module in Node.js, so no additional library dependencies are required.\n\n## References\n\n- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-78",
                    "url": "https://cwe.mitre.org/data/definitions/78.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-78"
                ]
              }
            },
            {
              "id": "c01f2e30-ff1e-354d-a93d-0454bcb3725f",
              "name": "Evaluation of Untrusted Data Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Evaluation of Untrusted Data Vulnerability\" in JavaScript is a security flaw that occurs when a program evaluates or executes data from an untrusted source. This can lead to serious security issues such as code injection attacks. In the provided code snippet, the `eval()` function is used to evaluate a string as JavaScript code. If the string comes from an untrusted source (in this case, `req.body.eqn`), it can potentially contain malicious code, which would be executed by the `eval()` function.\n\n## Mitigation Advice\n\nAvoid using `eval()` or similar functions that execute strings as code. If you must use them, make sure the data being evaluated is from a trusted source and properly sanitized. \n\n## Source Code Fix Recommendation\n\nInstead of using `eval()`, consider using safer alternatives like `JSON.parse()` or `parseInt()`. Here's how you can modify the provided code snippet:\n\n```javascript\nlet eqn = req.body.eqn;\nif (typeof eqn === 'string') {\n    eqn = parseInt(eqn, 10);\n}\n```\n\nIn this code, `parseInt()` is used to convert the string to a number. If the string contains anything other than a number, `parseInt()` will return `NaN`, effectively neutralizing any malicious code.\n\n## Library Dependencies\n\nThe provided code snippet seems to be using Express.js, a web application framework for Node.js. Therefore, the following library dependencies are required:\n\n- express\n- body-parser (for parsing the body of the request)\n\n## References\n\n- [OWASP: Evaluation of Untrusted Data](https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet_in_Java.html)\n- [CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')](https://cwe.mitre.org/data/definitions/95.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-95",
                    "url": "https://cwe.mitre.org/data/definitions/95.html"
                  }
                ],
                "severity": "LOW",
                "kind": "FAIL",
                "tags": [
                  "CWE-95"
                ]
              }
            },
            {
              "id": "21ea3123-3174-3d79-b784-74a27a5252e9",
              "name": "\"Postgresql Server Vulnerability to MITN Attacks due to Disabled TLS and Sequelize's Non-Enforcement of TLS\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability arises when a PostgreSQL server is configured to accept connections without Transport Layer Security (TLS), and Sequelize, a promise-based Node.js Object-Relational Mapping (ORM) for SQL databases, does not enforce TLS. This can expose the server to Man-In-The-Middle (MITM) attacks where an attacker can intercept and possibly alter the communication between the client and the server.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Enable and enforce TLS on your PostgreSQL server. This will encrypt the communication between the client and the server, making it difficult for an attacker to read or modify the data.\n\n2. Configure Sequelize to use SSL/TLS for database connections. This will ensure that Sequelize only communicates with the server over a secure connection.\n\n## Source Code Fix Recommendation\n\nYou can enforce SSL/TLS in Sequelize by adding the `dialectOptions` property to the configuration object:\n\n```javascript\nmodule.exports = {\n  username: process.env.MYSQL_USER,\n  password: process.env.MYSQL_PASSWORD,\n  database: process.env.MYSQL_DATABASE,\n  host: process.env.MYSQL_HOST || 'mysql-db',\n  port: process.env.MYSQL_PORT || 3306,\n  dialect: 'mysql',\n  dialectOptions: {\n    ssl: {\n      require: true,\n      rejectUnauthorized: false\n    }\n  }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `dotenv`: To load environment variables from a `.env` file.\n- `sequelize`: To interact with the MySQL database.\n\n## References\n\n- [OWASP Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-319",
                    "url": "https://cwe.mitre.org/data/definitions/319.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-319"
                ]
              }
            },
            {
              "id": "c5acd640-04b7-38a5-9c7a-0d8fd8be07d7",
              "name": "Vulnerable Hash Algorithm",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in JavaScript occurs when a weak cryptographic hash function, such as MD5, is used for security-critical functionality. MD5 is considered to be a weak hash function as it is susceptible to hash collisions, where different inputs produce the same hash output. This can lead to various security issues such as password cracking, data integrity attacks, and other forms of data tampering.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a stronger hash function such as SHA-256 or SHA-3. These hash functions are currently considered to be secure for most purposes. Additionally, when hashing passwords, it is recommended to use a function designed for password hashing, such as bcrypt, scrypt, or Argon2.\n\n## Source Code Fix Recommendation\n\nIf you are using the `crypto` library's `createHash` function with 'md5' as the argument, replace 'md5' with 'sha256' or 'sha3'.\n\n```javascript\n// Vulnerable code\nconst crypto = require('crypto');\nconst hash = crypto.createHash('md5');\nhash.update('some data to hash');\nconsole.log(hash.digest('hex'));\n\n// Fixed code\nconst crypto = require('crypto');\nconst hash = crypto.createHash('sha256');\nhash.update('some data to hash');\nconsole.log(hash.digest('hex'));\n```\n\n## Library Dependencies\n\nThe code example requires the `crypto` library, which is a built-in module in Node.js, so no additional installation is necessary.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-327",
                    "url": "https://cwe.mitre.org/data/definitions/327.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-327"
                ]
              }
            },
            {
              "id": "bab5710e-f80a-3d06-a815-795f80c5ba2a",
              "name": "\"Undetected CSRF Middleware in Your Express Application\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Request Forgery (CSRF) is a type of attack that occurs when a malicious web site, email, blog, instant message, or program causes a user's web browser to perform an unwanted action on a trusted site for which the user is currently authenticated. If the application does not have CSRF protection middleware, it is vulnerable to this type of attack.\n\nIn the context of Express.js, if the application does not use any CSRF protection middleware, it is vulnerable to CSRF attacks. This is because Express.js does not include CSRF protection in its core, and it must be added manually.\n\n## Mitigation Advice\n\nTo mitigate CSRF attacks, you should use CSRF protection middleware. There are several CSRF protection middleware available for Express.js, such as `csurf`. This middleware creates a CSRF token that must be sent with requests that change server state. Without the token, the server will not accept the request.\n\n## Source Code Fix Recommendation\n\nFirst, install the `csurf` middleware:\n\n```bash\nnpm install csurf\n```\n\nThen, use it in your Express.js application:\n\n```javascript\nvar express = require('express')\nvar cookieParser = require('cookie-parser')\nvar csrf = require('csurf')\n\nvar csrfProtection = csrf({ cookie: true })\nvar app = express()\n\napp.use(cookieParser())\n\napp.get('/form', csrfProtection, function (req, res) {\n  // pass the csrfToken to the view\n  res.render('send', { csrfToken: req.csrfToken() })\n})\n\napp.post('/process', csrfProtection, function (req, res) {\n  // process the request\n})\n```\n\nIn this example, the `csrfProtection` middleware is used to protect the routes. The CSRF token is passed to the view when rendering the form, and it must be included in the form submission.\n\n## Library Dependencies\n\n- express\n- cookie-parser\n- csurf\n\n## References\n\n- [OWASP CSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n- [CWE-352: Cross-Site Request Forgery (CSRF)](https://cwe.mitre.org/data/definitions/352.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-352",
                    "url": "https://cwe.mitre.org/data/definitions/352.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-352"
                ]
              }
            },
            {
              "id": "fd7234c9-f60f-32b7-86c2-9d3be0e45876",
              "name": "\"XML Parsing Library Found: Disable External Entity Resolution to Avoid XXE Attacks\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nXML External Entity (XXE) attacks occur when an XML parser processes XML input that contains a reference to an external entity. This can lead to the disclosure of confidential data, denial of service, server side request forgery, port scanning from the perspective of the machine where the parser is located, and other system impacts.\n\nIn JavaScript, if you're using the `libxmljs` library to parse XML data, you might be vulnerable to XXE attacks if you don't disable the resolution of external entities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should disable the resolution of external entities in the XML parser. This can be done by setting the `noent` option to `false` when parsing XML data.\n\n## Source Code Fix Recommendation\n\nHere's how you can disable the resolution of external entities in `libxmljs`:\n\n```javascript\nvar libxmljs = require(\"libxmljs\");\n\nvar xml = \"...\"; // your XML data\n\nvar xmlDoc = libxmljs.parseXmlString(xml, {noent: false});\n```\n\nIn this code, the `noent` option is set to `false`, which disables the resolution of external entities.\n\n## Library Dependencies\n\nThe only library dependency required by the code example is `libxmljs`.\n\n## References\n\n- [OWASP XXE Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n- [CWE-611: Improper Restriction of XML External Entity Reference ('XXE')](https://cwe.mitre.org/data/definitions/611.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-611",
                    "url": "https://cwe.mitre.org/data/definitions/611.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-611"
                ]
              }
            },
            {
              "id": "f9220330-3239-30f0-bb86-58261d761080",
              "name": "\"Libxml library's `noent` attribute set to `true` can lead to XXE vulnerabilities; recommended to set `noent` to `false` for protection.\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `noent` attribute in the `libxmljs` library in JavaScript is used to substitute entities in an XML document. When this attribute is set to `true`, it can lead to XML External Entity (XXE) vulnerabilities. XXE vulnerabilities occur when an application processing XML input allows the inclusion of dynamic external entities. This can lead to the disclosure of confidential data, denial of service, server-side request forgery, port scanning from the perspective of the machine where the parser is located, and other system impacts.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to disable the `noent` attribute by setting it to `false`. This will prevent the parser from substituting entities with their values, thus preventing XXE attacks.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the vulnerability in the provided code:\n\n```javascript\nvar products = libxmljs.parseXmlString(req.files.products.data.toString('utf8'), {noent:false,noblanks:true})\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- `libxmljs`: A library for parsing and serializing XML documents.\n\n## References\n\n- [OWASP XXE Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n- [CWE-611: Improper Restriction of XML External Entity Reference ('XXE')](https://cwe.mitre.org/data/definitions/611.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-611",
                    "url": "https://cwe.mitre.org/data/definitions/611.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-611"
                ]
              }
            },
            {
              "id": "ba115ef7-d9a2-341d-83d4-44b83813a964",
              "name": "Vulnerable Hash Algorithm",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA \"Vulnerable Hash Algorithm\" vulnerability in JavaScript occurs when a weak cryptographic hash function, such as MD5, is used for security-critical functionality. MD5 is considered to be a weak hash function as it is susceptible to hash collisions, where different inputs produce the same hash output. This can lead to various security issues such as password cracking, data integrity attacks, and other forms of data tampering.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a stronger hash function such as SHA-256 or SHA-3. These hash functions are currently considered to be secure for most purposes. Additionally, when hashing passwords, it is recommended to use a function designed for password hashing, such as bcrypt, scrypt, or Argon2.\n\n## Source Code Fix Recommendation\n\nIf you are using the `crypto` library's `createHash` function with 'md5' as the argument, replace 'md5' with 'sha256' or 'sha3'.\n\n```javascript\n// Vulnerable code\nconst crypto = require('crypto');\nconst hash = crypto.createHash('md5');\nhash.update('some data to hash');\nconsole.log(hash.digest('hex'));\n\n// Fixed code\nconst crypto = require('crypto');\nconst hash = crypto.createHash('sha256');\nhash.update('some data to hash');\nconsole.log(hash.digest('hex'));\n```\n\n## Library Dependencies\n\nThe code example requires the `crypto` library, which is a built-in module in Node.js, so no additional installation is necessary.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-327",
                    "url": "https://cwe.mitre.org/data/definitions/327.html"
                  }
                ],
                "severity": "HIGH",
                "kind": "FAIL",
                "tags": [
                  "CWE-327"
                ]
              }
            },
            {
              "id": "d6457d2b-7a66-357e-8fae-e1e7b70dc714",
              "name": "Unsecured Web Address",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nAn \"Unsecured Web Address\" vulnerability in JavaScript refers to the use of insecure HTTP protocol to load resources or link to external sites. This can expose the application to man-in-the-middle (MITM) attacks, where an attacker can intercept and potentially alter the communication between the user and the server. In this case, the vulnerability sink is the insecure HTTP link to the HTML5 Shim library hosted on Google Code: `http://html5shim.googlecode.com`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always use secure HTTPS protocol when loading resources or linking to external sites. HTTPS ensures that the communication between the user and the server is encrypted and cannot be intercepted or altered by attackers.\n\n## Source Code Fix Recommendation\n\nReplace the insecure HTTP link with a secure HTTPS link:\n\n```javascript\n// Old insecure link\n// <script src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"></script>\n\n// New secure link\n<script src=\"https://html5shim.googlecode.com/svn/trunk/html5.js\"></script>\n```\n\n## Library Dependencies\n\nThe code example requires the HTML5 Shim library, which is a JavaScript workaround for HTML5 elements in older browsers. It is hosted on Google Code and can be loaded via the provided link.\n\n## OWASP Resources\n\n- [Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)\n- [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)\n\nPlease note that all links are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-319",
                    "url": "https://cwe.mitre.org/data/definitions/319.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-319"
                ]
              }
            },
            {
              "id": "c9476c0e-2a36-30ee-9141-e9d85491bb1a",
              "name": "\"Detected Vulnerability in node-serialize Library Allowing Arbitrary Code Execution\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `node-serialize` library in JavaScript is vulnerable to arbitrary code execution. This vulnerability allows an attacker to execute arbitrary code on the server by providing a serialized object with a malicious payload. This happens because the `node-serialize` library uses the `eval()` function to deserialize objects, which can execute any JavaScript code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should avoid using the `node-serialize` library for deserializing untrusted data. Instead, use a safe alternative like `JSON.parse()`. \n\nAlso, always validate and sanitize user input to prevent code injection attacks. \n\n## Source Code Fix Recommendation\n\nReplace the `node-serialize` library with a safer alternative. Here is an example of how to do it:\n\n```javascript\n// Instead of this:\nvar serialize = require(\"node-serialize\");\n\n// Use this:\nvar serialize = JSON.parse;\n```\n\n## Library Dependencies\n\nThe code example requires the `node-serialize` library to execute properly.\n\n## OWASP Resources\n\n- [OWASP Top 10 2017: A8-Insecure Deserialization](https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-502: Deserialization of Untrusted Data](https://cwe.mitre.org/data/definitions/502.html)\n- [CWE-94: Improper Control of Generation of Code ('Code Injection')](https://cwe.mitre.org/data/definitions/94.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-502",
                    "url": "https://cwe.mitre.org/data/definitions/502.html"
                  },
                  {
                    "id": "CWE-94",
                    "url": "https://cwe.mitre.org/data/definitions/94.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-502",
                  "CWE-94"
                ]
              }
            },
            {
              "id": "9dcfa863-6df2-331a-be98-ba857c5348e9",
              "name": "Unsecured URL Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnsecured URL Vulnerability in JavaScript refers to the security risk associated with the use of unencrypted HTTP protocol in URLs. This vulnerability can lead to various types of attacks such as Man-in-the-Middle (MitM) attacks, where an attacker can intercept and potentially alter the communication between two parties without their knowledge. This can lead to unauthorized access to sensitive information, data tampering, and other security breaches.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure communication protocols such as HTTPS instead of HTTP. HTTPS ensures that the communication between the client and the server is encrypted and secure. Also, validate and sanitize all inputs and outputs to prevent other types of attacks such as Cross-Site Scripting (XSS) and SQL Injection.\n\n## Source Code Fix Recommendation\n\nInstead of using:\n\n```javascript\nvar url = \"http://example.com\";\n```\n\nUse:\n\n```javascript\nvar url = \"https://example.com\";\n```\n\n## Library Dependencies\n\nNo additional library dependencies are required for this code example.\n\n## References\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-319",
                    "url": "https://cwe.mitre.org/data/definitions/319.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-319"
                ]
              }
            },
            {
              "id": "1b1c4619-f040-3f90-9111-3ca724783e40",
              "name": "\"Potential XSS Vulnerability from User-Controlled Data in HTML String\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA potential Cross-Site Scripting (XSS) vulnerability from user-controlled data in HTML string exists when an application includes untrusted data in a new HTML string used in a JavaScript context. This vulnerability can occur when user input is included in a string that is used in a dynamic SQL query. An attacker can inject malicious scripts into the application, which are then executed by the victim's browser.\n\nIn the provided code snippet, the application is vulnerable to SQL Injection, which could potentially lead to XSS if the data is later used in an HTML context.\n\n```javascript\nvar query = \"SELECT name,id FROM Users WHERE login='\" + req.body.login + \"'\";\n```\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Use parameterized queries or prepared statements instead of string concatenation to prevent SQL Injection.\n2. Always validate and sanitize user input to ensure it does not contain malicious scripts.\n3. Use Content Security Policy (CSP) to reduce the risk of XSS attacks.\n4. Use HTTPOnly cookies to prevent access from JavaScript.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix using parameterized queries:\n\n```javascript\nvar sql = \"SELECT name,id FROM Users WHERE login= ?\";\nvar inserts = [req.body.login];\nsql = mysql.format(sql, inserts);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Express.js: For handling HTTP requests and responses.\n- MySQL: For interacting with a MySQL database.\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  },
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79",
                  "CWE-89"
                ]
              }
            },
            {
              "id": "055908f0-60ec-34e2-99d7-df61704e3569",
              "name": "Potential Path Traversal Vulnerability Detected in `path.join` or `path.resolve` Function Due to Unsanitized User Input",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nA potential Path Traversal vulnerability has been detected in the `path.join` or `path.resolve` function due to unsanitized user input. This vulnerability, also known as directory traversal, is a type of application security vulnerability which allows attackers to read arbitrary files on the application's host machine, that are outside of the intended directory. In JavaScript, this vulnerability can occur when the application uses user input to construct a path to a file or directory without properly sanitizing it.\n\nIn the provided code snippet, the `sequelize.import` function is using `path.join` to construct a path to a file. If the `file` variable is user-controlled and not properly sanitized, an attacker could manipulate the path to access files outside of the intended directory.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to validate and sanitize user input. Avoid using user input to form file paths where possible. If it is necessary, ensure that the input is strictly validated. This can include checking for path traversal sequences (../ or ..\\), null bytes (%00), or newlines (%0A or %0D).\n\n## Source Code Fix Recommendation\n\n```javascript\nvar path = require('path');\nvar file = getUserInput();\n\n// Validate user input\nif (!isValidInput(file)) {\n    throw new Error('Invalid input');\n}\n\n// Sanitize user input\nfile = sanitizeInput(file);\n\nvar model = sequelize.import(path.join(__dirname, file));\n```\n\nIn this example, `isValidInput` and `sanitizeInput` are placeholder functions that you would need to implement. `isValidInput` should return a boolean indicating whether the input is valid, and `sanitizeInput` should return a sanitized version of the input.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `sequelize`: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n- `path`: A core Node.js module for handling and transforming file paths.\n\n## References\n\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)\n- [CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')](https://cwe.mitre.org/data/definitions/22.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-22"
                ]
              }
            },
            {
              "id": "0960e248-84d3-3502-bcd0-541e59f5ebba",
              "name": "\"SQL Injection Risk from Untrusted Input Concatenation: Use Data Replacement or Binding\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe code snippet provided is vulnerable to SQL Injection due to the concatenation of untrusted input directly into a SQL query. This vulnerability allows an attacker to manipulate the SQL query by injecting arbitrary SQL code through the `req.body.login` input.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use parameterized queries or prepared statements. These techniques ensure that user inputs are always treated as literal values, not part of the SQL command. This way, even if an attacker attempts to inject SQL code, it will not be executed as part of the command.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using Sequelize's built-in protection against SQL Injection:\n\n```javascript\nvar query = \"SELECT name,id FROM Users WHERE login= :login\";\ndb.sequelize.query(query, {\n\tmodel: db.User,\n\treplacements: { login: req.body.login }\n}).then(user => {\n\t// rest of the code\n}).catch(err => {\n\t// error handling\n});\n```\n\nIn this version, `:login` is a placeholder that Sequelize will replace with the value of `req.body.login`, properly escaped to prevent SQL Injection.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n- Express.js: A web application framework for Node.js, used for routing and handling HTTP requests and responses.\n\n## References\n\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-89"
                ]
              }
            },
            {
              "id": "af01a7ee-caac-33b0-a917-bfcfb3bce866",
              "name": "Unset 'secure' in default session middleware settings vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `secure` flag in the session middleware settings of an Express.js application is used to specify whether cookies should be sent over secure connections only. When `secure` is set to `false`, cookies can be sent over unencrypted connections, which makes them vulnerable to interception and manipulation by attackers. This is a violation of the OWASP Secure Coding Practices, which recommend that all cookies should be sent over secure connections only.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should set the `secure` flag to `true` in your session middleware settings. This will ensure that cookies are sent over secure connections only. However, you should be aware that this will prevent your application from sending cookies over unencrypted connections, which may impact functionality if your application is not set up to use HTTPS.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the vulnerability in your source code:\n\n```javascript\napp.use(session({\n  secret: 'keyboard cat',\n  resave: true,\n  saveUninitialized: true,\n  cookie: { secure: true }\n}))\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- express\n- express-session\n\n## References\n\n- [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n- [CWE-319: Cleartext Transmission of Sensitive Information](https://cwe.mitre.org/data/definitions/319.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-319",
                    "url": "https://cwe.mitre.org/data/definitions/319.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-319"
                ]
              }
            },
            {
              "id": "d20ba9e2-94ee-370c-9227-db01ee13e9a0",
              "name": "Detected Hard-Coded Credential Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nDetected Hard-Coded Credential Vulnerability refers to the insecure practice of embedding plaintext credentials directly within the source code. This vulnerability can lead to unauthorized access if the source code is ever exposed, as the credentials are easily readable. In JavaScript, this vulnerability can occur when sensitive data like API keys, database credentials, or in this case, a secret key for session management, are hard-coded into the application.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, sensitive data should never be hard-coded directly into the source code. Instead, use environment variables to store this data. Environment variables are a type of dynamic-named value that can affect the way running processes behave on a computer. They are part of the environment in which a process runs.\n\n## Source Code Fix Recommendation\n\nInstead of hard-coding the secret directly into the code, you should store it in an environment variable. Here's how you can do it:\n\n```javascript\nconst express = require('express');\nconst session = require('express-session');\n\nconst app = express();\n\napp.use(session({\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: true\n}));\n\n// rest of your code\n```\n\nIn this code, `process.env.SESSION_SECRET` is used to access the `SESSION_SECRET` environment variable. You can set this variable in your server's environment, or if you're using a platform like Heroku, in the settings for your application.\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- express\n- express-session\n\n## References\n\n- [OWASP Top 10-2017 A2-Broken Authentication](https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication)\n- [OWASP Top 10-2017 A3-Sensitive Data Exposure](https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure)\n- [CWE-798: Use of Hard-coded Credentials](https://cwe.mitre.org/data/definitions/798.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-798",
                    "url": "https://cwe.mitre.org/data/definitions/798.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-798"
                ]
              }
            },
            {
              "id": "31813b77-cfad-3bb8-8371-b438a70a3e1b",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a Promise is rejected, but this rejection is not caught or handled with a `.catch()` method. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information in error messages.\n\nIn the provided code, the vulnerability lies in the `.catch()` block. The error `err` is caught, but nothing is done with it. This means that if the Promise is rejected, the error will not be handled properly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle Promise rejections. This can be done by adding a `.catch()` block to your Promise chain, and then handling the error appropriately within this block. This might involve logging the error, returning a default value, or throwing an error to be caught higher up in your application.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.sequelize.query(query, {\n\tmodel: db.User\n}).then(user => {\n\tif (user.length) {\n\t\tvar output = {\n\t\t\tuser: {\n\t\t\t\tname: user[0].name,\n\t\t\t\tid: user[0].id\n\t\t\t}\n\t\t}\n\t\tres.render('app/usersearch', {\n\t\t\toutput: output\n\t\t})\n\t} else {\n\t\treq.flash('warning', 'User not found')\n\t\tres.render('app/usersearch', {\n\t\t\toutput: null\n\t\t})\n\t}\n}).catch(err => {\n\tconsole.error(err);\n\treq.flash('error', 'An error occurred while searching for the user');\n\tres.render('app/usersearch', {\n\t\toutput: null\n\t});\n});\n```\n\nIn this fixed version, the `.catch()` block logs the error and then flashes a generic error message to the user. It also renders the `usersearch` view with no output.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- Sequelize (for the `db.sequelize.query()` method)\n- Express (for the `res.render()` method)\n- Connect-flash (for the `req.flash()` method)\n\n## References\n\n- [OWASP Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "a46d83fc-ded8-3469-8316-e0528591d6d3",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when user-supplied data is not properly sanitized or escaped before being included in an EJS template. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts into web pages viewed by other users. These scripts can steal sensitive information, perform actions on behalf of the user, or exploit other vulnerabilities in the user's browser.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always escape user-supplied data before including it in an EJS template. This can be done using the `<%= %>` syntax in EJS, which automatically escapes HTML characters. Additionally, it is a good practice to validate and sanitize user input on the server side before using it in any context.\n\n## Source Code Fix Recommendation\n\nThe vulnerable code:\n\n```javascript\nListing products with <strong>search query: </strong> <%- output.searchTerm %>\n```\n\nThe fixed code:\n\n```javascript\nListing products with <strong>search query: </strong> <%= output.searchTerm %>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## References\n\n- [OWASP XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "90408b14-a210-379b-a93e-9fa7a1965540",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when unescaped external data is used in an EJS template. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts into web pages viewed by other users. These scripts can steal sensitive information, manipulate web content, or perform actions on behalf of the user without their consent.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always escape external data before using it in your templates. This can be done using the `<%- %>` syntax in EJS, which escapes HTML entities. Never trust user input or any data that comes from an external source.\n\n## Source Code Fix Recommendation\n\nIn your specific code example, the `id` property of the `products` array is being output without being escaped. This can be fixed by using the `<%- %>` syntax to escape the `id`:\n\n```javascript\n<td><%- output.products[i].id %></td>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies to execute properly:\n\n- EJS\n\n## OWASP and CWE Resources\n\n- [OWASP Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "266a70bf-e91c-31bb-8b33-7be81335992b",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when unescaped external data is used in an EJS template. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts into web pages viewed by other users. These scripts can steal sensitive information, perform actions on behalf of the user, or exploit other vulnerabilities in the user's browser.\n\nIn the provided code snippet, the product name is being outputted directly into the HTML without any form of escaping or sanitization. If the product name contains any HTML or JavaScript code, it will be executed by the browser.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always escape any external data that is being outputted into an HTML context. This can be done using the `escape` function provided by EJS, or by using a library that provides HTML escaping functionality.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code snippet:\n\n```ejs\n<td><%= ejs.escape(output.products[i].name) %></td>\n```\n\nIn this version, the `escape` function is used to escape any HTML or JavaScript code in the product name, preventing it from being executed by the browser.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## OWASP Resources\n\n- [Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)\n- [OWASP Cheat Sheet Series - XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "84b854a1-f34b-311e-ba56-c80d48d54711",
              "name": "Preventing SQL Injection Vulnerability through Prepared Statements, Parameterized Queries, and ORM Frameworks",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nSQL Injection is a code injection technique that attackers can use to exploit vulnerabilities in a web application's database layer. This happens when the application's controls allow unfiltered user-supplied input into SQL queries. In JavaScript, this vulnerability can be exploited when using SQL-based databases such as MySQL, PostgreSQL, SQLite, etc.\n\nThe vulnerability sink in the provided code snippet is the `query` variable that is passed directly to the `db.sequelize.query()` function. If the `query` variable is constructed using user-supplied input, it can lead to SQL Injection attacks.\n\n## Mitigation Advice\n\nTo prevent SQL Injection vulnerabilities, it is recommended to use Prepared Statements, Parameterized Queries, or ORM (Object-Relational Mapping) Frameworks. These techniques ensure that user-supplied input is always treated as literal data, not part of the SQL command.\n\n- **Prepared Statements**: These are SQL statements that are sent to and parsed by the database server separately from any parameters. This way, it is impossible for an attacker to inject malicious SQL.\n\n- **Parameterized Queries**: These are database queries in which placeholders are used for parameters and the parameter values are supplied at execution time.\n\n- **ORM Frameworks**: These are programming techniques for converting data between incompatible type systems using object-oriented programming languages. They create a \"virtual object database\" that can be used from within the programming language.\n\n## Source Code Fix Recommendation\n\n```javascript\nlet userId = getUserInput();\n\n// Use sequelize's built-in support for parameterized queries\ndb.sequelize.query('SELECT * FROM users WHERE id = :userId', \n  { replacements: { userId: userId }, type: db.sequelize.QueryTypes.SELECT }\n).then(users => {\n  console.log(users)\n})\n```\n\n## Library Dependencies\n\n- sequelize\n\n## References\n\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [OWASP Sequelize](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#sequelize)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-89"
                ]
              }
            },
            {
              "id": "2a87e4aa-7bb1-34b0-9997-53cf7be00f72",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. This allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nEJS (Embedded JavaScript) templates are a popular templating engine in JavaScript. The vulnerability arises when the `<%- %>` syntax is used in EJS templates, which does not escape HTML entities, thus allowing potential Cross-Site Scripting (XSS) attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always use the `<%= %>` syntax in EJS templates, which escapes HTML entities. This will prevent potential XSS attacks. \n\nAlso, always validate and sanitize user input to ensure that it does not contain malicious scripts. Use a trusted library or framework that makes it easy to escape potentially harmful characters.\n\n## Source Code Fix Recommendation\n\nReplace the `<%- %>` syntax with `<%= %>` in your EJS templates. Here is the fixed code:\n\n```javascript\n<td><%= output.products[i].code %></td>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "a8c344fb-e0b9-3bd0-beba-bc74b30a9708",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when unescaped external data is used in an EJS template. This can lead to Cross-Site Scripting (XSS) attacks, where an attacker can inject malicious scripts into web pages viewed by other users. These scripts can steal sensitive information, perform actions on behalf of the user, or exploit other vulnerabilities in the user's browser.\n\nIn the provided code snippet, the vulnerability arises from the use of `<%-` instead of `<%=`, which results in the output not being escaped:\n\n```javascript\n<td><%- output.products[i].tags %></td>\n```\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always escape external data that is being output to the browser. This can be done by using `<%=` instead of `<%-` in EJS templates. This will ensure that any HTML special characters are properly escaped, preventing them from being interpreted as code by the browser.\n\n## Source Code Fix Recommendation\n\nHere is the fixed version of the code:\n\n```javascript\n<td><%= output.products[i].tags %></td>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS: A JavaScript templating engine.\n\n## OWASP and CWE Resources\n\n- [OWASP Cross-Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "45081c46-bcda-384a-96d1-9d48f46fb46a",
              "name": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"EJS Template XSS Vulnerability Detected Due to Unescaped External Data\" is a vulnerability that occurs when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. This allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nIn the provided code snippet, the application is using EJS (Embedded JavaScript) templates to generate HTML markup with plain JavaScript. The `<%- %>` syntax in EJS is used to output the unescaped value into the template. This means that if `output.products[i].description` contains any malicious script, it will be executed when the page is rendered.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always escape untrusted data based on the HTML context (body, attribute, JavaScript, CSS, or URL) that the data will be placed into. In EJS, you can use `<%= %>` syntax to output the escaped value into the template.\n\n## Source Code Fix Recommendation\n\nReplace `<%- output.products[i].description %>` with `<%= output.products[i].description %>`. The updated code should look like this:\n\n```javascript\n<td><%= output.products[i].description %></td>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## References\n\n- [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "6b3d767a-cfe7-3b6c-87d8-4ff57074985f",
              "name": "\"Potential XSS Vulnerability from User-Controlled Data in HTML String\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Scripting (XSS) vulnerabilities occur when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nIn the provided JavaScript code, the application is executing a shell command with user-controlled input (`req.body.address`). This is a serious security risk as it allows an attacker to execute arbitrary commands on the server. Although this is not directly an XSS vulnerability, it can lead to XSS if the output of the command execution (`stdout` or `stderr`) contains user-controlled input and is rendered in a web page without proper escaping.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Avoid using `exec` with user-controlled input. If you need to run a shell command, consider using safer alternatives that allow you to pass arguments separately from the command itself, such as `child_process.execFile` or `child_process.spawn`.\n\n2. Always validate and sanitize user input. Use a library or framework that makes it easy to validate and sanitize input, and reject input that doesn't meet your criteria.\n\n3. Escape any user-controlled data that is included in a web page. This can prevent XSS attacks even if user-controlled data ends up in the output of a shell command.\n\n## Source Code Fix Recommendation\n\nHere is a safer version of the code using `child_process.execFile`:\n\n```javascript\nconst { execFile } = require('child_process');\n\nlet address = req.body.address;\n// TODO: Add validation and sanitization of address here\n\nexecFile('ping', ['-c', '2', address], function (err, stdout, stderr) {\n    output = stdout + stderr;\n    // TODO: Add escaping of output here\n    res.render('app/ping', {\n        output: output\n    });\n});\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Express.js (for handling HTTP requests and responses)\n- EJS or another template engine (for rendering the web page)\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [OWASP Command Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)\n- [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  },
                  {
                    "id": "CWE-78",
                    "url": "https://cwe.mitre.org/data/definitions/78.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79",
                  "CWE-78"
                ]
              }
            },
            {
              "id": "7e2b05b3-38c9-35ad-9929-bf922d0085db",
              "name": "Unselected Field Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnselected Field Database Query Vulnerability in JavaScript occurs when a developer does not explicitly specify the fields to be returned from a database query. This can lead to the exposure of sensitive data if the query is used to return results directly to the client. An attacker can potentially gain access to data that they are not authorized to view.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should always explicitly specify the fields to be returned from a database query. This can be done by passing an array of field names to the `attributes` option in the query. \n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.Product.findAll({\n  attributes: ['field1', 'field2', 'field3'] // specify the fields to be returned\n}).then(products => {\n  // ...\n});\n```\n\nIn the above code, replace `'field1'`, `'field2'`, and `'field3'` with the actual field names of your `Product` model.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n\n## References\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-209: Information Exposure Through an Error Message](https://cwe.mitre.org/data/definitions/209.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-209",
                    "url": "https://cwe.mitre.org/data/definitions/209.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-209"
                ]
              }
            },
            {
              "id": "c8d00ddc-cb2f-3386-8938-1060a8e7a487",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but there is no error handling mechanism in place to catch and handle the error. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information in error messages.\n\nIn the provided code, the promise returned by `db.Product.findAll()` is not handled properly. If the promise is rejected (for example, if there is a problem connecting to the database), there is no error handling mechanism in place to catch and handle the error.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always have a `.catch()` block for every `.then()` block in your promises. The `.catch()` block will catch any errors that occur in the promise chain and handle them appropriately.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the provided code:\n\n```javascript\ndb.Product.findAll().then(products => {\n\toutput = {\n\t\tproducts: products\n\t}\n\tres.render('app/products', {\n\t\toutput: output\n\t})\n}).catch(err => {\n\t// Handle the error here\n\tconsole.error(err);\n\tres.status(500).send('An error occurred');\n});\n```\n\nIn this fixed code, if the promise is rejected, the error will be caught and logged to the console, and a 500 status code will be sent to the client.\n\n## Library Dependencies\n\nThe provided code appears to require the following libraries:\n\n- A database library that provides the `db.Product.findAll()` function. This could be Sequelize, for example.\n- An Express.js-like library that provides the `res.render()` function.\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_security_cheat_sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "caa78969-106f-30a0-815f-8634d1d554c0",
              "name": "Unselected Field Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unselected Field Database Query Vulnerability\" in JavaScript is a type of security vulnerability that occurs when a developer does not explicitly specify the fields to be returned from a database query. This can lead to the exposure of sensitive data if the query returns more data than intended. In the provided code, the `findAll` method is used without specifying the fields to be returned, which means all fields in the `Product` table will be returned.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should always explicitly specify the fields to be returned from a database query. This can be done using the `attributes` option in the `findAll` method. By doing this, developers can ensure that only the necessary data is returned, reducing the risk of exposing sensitive data.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.Product.findAll({\n    attributes: ['id', 'name', 'price'], // specify the fields to be returned\n    where: {\n        name: {\n            [Op.like]: '%' + req.body.name + '%'\n        }\n    }\n}).then(products => {\n    // ...\n});\n```\n\nIn this fixed version, the `findAll` method will only return the `id`, `name`, and `price` fields from the `Product` table.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n- Express: A fast, unopinionated, and flexible Node.js web application framework.\n\n## References\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-209: Information Exposure Through an Error Message](https://cwe.mitre.org/data/definitions/209.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-209",
                    "url": "https://cwe.mitre.org/data/definitions/209.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-209"
                ]
              }
            },
            {
              "id": "0e6fc9e5-03de-37aa-af56-1faa4c6e245a",
              "name": "Unselected Field Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unselected Field Database Query Vulnerability\" in JavaScript is a security flaw that occurs when a developer does not explicitly define the fields to be returned from a database query. This can lead to the exposure of sensitive data. In the provided code, the query is fetching a product by its 'id' from the database, but it does not specify which fields of the product should be returned. This means that all fields of the product, including potentially sensitive ones, will be returned.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should always explicitly define the fields to be returned from a database query. This can be done by adding a 'select' clause to the query, which specifies the fields to be returned. If a field is not specified in the 'select' clause, it will not be returned by the query.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.Product.find({\n    where: {\n        'id': req.query.id\n    },\n    attributes: ['id', 'name', 'description'] // specify the fields to be returned\n}).then(product => {\n    // ...\n});\n```\n\nIn this fixed version, the 'attributes' option is used to specify the fields to be returned by the query. Only the 'id', 'name', and 'description' fields of the product will be returned.\n\n## Library Dependencies\n\nThe provided code appears to be using the Sequelize ORM for Node.js. Therefore, the following library dependencies are required:\n\n- `sequelize`: This is the main Sequelize library.\n- `pg` or `mysql`: These are the database drivers. You should install the one that matches your database system.\n- `express`: This is used to handle HTTP requests and responses.\n\n## References\n\n- [OWASP - SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-209: Information Exposure Through an Error Message](https://cwe.mitre.org/data/definitions/209.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-209",
                    "url": "https://cwe.mitre.org/data/definitions/209.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-209"
                ]
              }
            },
            {
              "id": "d956d5d7-fa6d-32d3-9cd0-0b60c5231067",
              "name": "XSS Vulnerability from User-Controlled Data in HTML String",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Scripting (XSS) vulnerabilities occur when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nIn the provided JavaScript code, the application is vulnerable to XSS because it includes user-controlled data (`req.body.name`) in the HTML output without proper escaping. This allows an attacker to inject malicious scripts by sending a specially crafted `name` parameter.\n\n## Mitigation Advice\n\nTo mitigate XSS vulnerabilities, you should:\n\n- Use a safe API which avoids the use of the interpreter entirely or provides a parameterized interface.\n- For any data that is included in the HTML output, use proper output encoding or escaping.\n- Apply context-sensitive encoding when modifying the browser document on the client side.\n- Use an appropriate Content Security Policy (CSP) to reduce the severity of any XSS vulnerabilities.\n\n## Source Code Fix Recommendation\n\nIn the provided code, you can mitigate the XSS vulnerability by using a template engine that automatically escapes user-controlled data. For example, if you are using the EJS template engine, you can use `<%= output.searchTerm %>` to include `searchTerm` in the HTML output. This will automatically escape any special characters.\n\n```javascript\ndb.Product.findAll({\n\twhere: {\n\t\tname: {\n\t\t\t[Op.like]: '%' + req.body.name + '%'\n\t\t}\n\t}\n}).then(products => {\n\toutput = {\n\t\tproducts: products,\n\t\tsearchTerm: req.body.name\n\t}\n\tres.render('app/products', {\n\t\toutput: output\n\t})\n})\n```\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n- Express: A fast, unopinionated, minimalist web framework for Node.js.\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "3f9d0612-751a-37dd-91b8-d38a6efa8402",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a Promise is rejected, but this rejection is not caught or handled. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information or lead to other security vulnerabilities.\n\nIn the provided code, the Promise returned by `db.Product.find()` is not being handled for a case where it might get rejected. If for any reason the Promise is rejected (for example, a database error), there is no code to handle this rejection, which could lead to unhandled Promise rejection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always handle Promise rejections. This can be done by adding a `.catch()` block to the Promise chain. The `.catch()` block will catch any errors that occur in the Promise chain and allow you to handle them appropriately.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the provided code:\n\n```javascript\ndb.Product.find({\n\twhere: {\n\t\t'id': req.query.id\n\t}\n}).then(product => {\n\tif (!product) {\n\t\tproduct = {}\n\t}\n\toutput = {\n\t\tproduct: product\n\t}\n\tres.render('app/modifyproduct', {\n\t\toutput: output\n\t})\n}).catch(err => {\n\t// Handle the error here\n\tconsole.error(err);\n\tres.status(500).send('An error occurred');\n});\n```\n\nIn the above code, a `.catch()` block is added to handle any errors that occur in the Promise chain.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- A Promise-compatible database library (such as Sequelize) for `db.Product.find()`.\n- An Express.js-compatible server for handling requests and responses (`req`, `res`).\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_security_cheat_sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "fdc73081-90fc-38f0-8464-db9b877e8c76",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a Promise is rejected, but this rejection is not caught or handled with a `.catch()` method. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information in error messages.\n\nIn the provided code, the vulnerability lies in the `.catch()` block. If an error occurs during the execution of `product.save()`, the error is caught but not handled. This can lead to unhandled promise rejection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle promise rejections. This can be done by adding a `.catch()` block to your promises where you can define how your application should react in case of a failure. This could be logging the error, retrying the operation, or informing the user about the issue.\n\n## Source Code Fix Recommendation\n\nHere is a simple way to handle the error in the provided code:\n\n```javascript\nproduct.save().then(p => {\n\tif (p) {\n\t\treq.flash('success', 'Product added/modified!')\n\t\tres.redirect('/app/products')\n\t}\n}).catch(err => {\n\tconsole.error(err);\n\treq.flash('error', 'An error occurred while saving the product.');\n\tres.redirect('/app/error');\n});\n```\n\nIn this code, if an error occurs during the execution of `product.save()`, the error is logged to the console, an error message is flashed to the user, and the user is redirected to an error page.\n\n## Library Dependencies\n\nThe code example seems to be using the following libraries:\n\n- A promise-based library for database operations (e.g., Mongoose for MongoDB)\n- Express.js for handling HTTP requests and responses\n- Connect-flash for flashing messages in Express.js\n\n## References\n\n- [OWASP Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_security_cheat_sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "62bc3e5d-aa43-36a8-9c56-36406f37f48a",
              "name": "Unverified User Input IDOR Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnverified User Input IDOR (Insecure Direct Object References) Vulnerability is a type of security vulnerability that occurs when a function with no access control is used to access a specific resource directly. In JavaScript, this vulnerability can occur when a user-supplied input is used directly to access a database object without proper validation or authorization checks. This can allow an attacker to manipulate the input to access unauthorized data.\n\nIn the provided code snippet, the vulnerability arises from the use of `req.body.id` directly in the database query without any validation or authorization checks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate user input: Ensure that the user input matches the expected format and values. This can be done using regular expressions or built-in validation functions.\n\n2. Implement access control: Ensure that the user has the necessary permissions to access the requested resource. This can be done by checking the user's role or permissions before executing the database query.\n\n3. Use parameterized queries: This can help prevent SQL injection attacks by ensuring that user input is always treated as a literal value and not part of the SQL command.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```javascript\n// Assuming `userId` is the authenticated user's ID\nif (req.user.id !== req.body.id) {\n    return res.status(403).send(\"Unauthorized access\");\n}\n\ndb.Product.find({\n    where: {\n        'id': req.body.id\n    }\n}).then(product => {\n    // ...\n});\n```\n\n## Library Dependencies\n\nThe provided code snippet seems to be using the following libraries:\n\n- Express.js: For handling HTTP requests and responses.\n- Sequelize: For interacting with the database.\n\n## References\n\n- [CWE-639: Authorization Bypass Through User-Controlled Key](https://cwe.mitre.org/data/definitions/639.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-639",
                    "url": "https://cwe.mitre.org/data/definitions/639.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-639"
                ]
              }
            },
            {
              "id": "15724e00-e71c-3b1d-906e-22bafe0e35de",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but the rejection is not caught or handled. This can lead to unexpected application behavior and potential security vulnerabilities. In the provided code, if the `db.User.find` promise is rejected (for example, if there is a database error), there is no `.catch` block to handle the error, which could lead to an Unhandled Promise Rejection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle promise rejections by adding a `.catch` block after your `.then` block. This allows you to handle any errors that occur during the execution of the promise. In addition, you should also consider using `async/await` syntax, which can make your code more readable and easier to understand.\n\n## Source Code Fix Recommendation\n\nHere is the fixed code:\n\n```javascript\ndb.User.find({\n\twhere: {\n\t\t'id': req.body.id\n\t}\t\t\n}).then(user =>{\n\tif(req.body.password.length>0){\n\t\tif(req.body.password.length>0){\n\t\t\tif (req.body.password == req.body.cpassword) {\n\t\t\t\tuser.password = bCrypt.hashSync(req.body.password, bCrypt.genSaltSync(10), null)\n\t\t\t}else{\n\t\t\t\treq.flash('warning', 'Passwords dont match')\n\t\t\t\tres.render('app/useredit', {\n\t\t\t\t\tuserId: req.user.id,\n\t\t\t\t\tuserEmail: req.user.email,\n\t\t\t\t\tuserName: req.user.name,\n\t\t\t\t})\n\t\t\t\treturn\t\t\n\t\t\t}\n\t\t}else{\n\t\t\treq.flash('warning', 'Invalid Password')\n\t\t\tres.render('app/useredit', {\n\t\t\t\tuserId: req.user.id,\n\t\t\t\tuserEmail: req.user.email,\n\t\t\t\tuserName: req.user.name,\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n\tuser.email = req.body.email\n\tuser.name = req.body.name\n\tuser.save().then(function () {\n\t\treq.flash('success',\"Updated successfully\")\n\t\tres.render('app/useredit', {\n\t\t\tuserId: req.body.id,\n\t\t\tuserEmail: req.body.email,\n\t\t\tuserName: req.body.name,\n\t\t})\n\t}).catch(err => {\n\t\t// Handle the error here\n\t\tconsole.error(err);\n\t})\n}).catch(err => {\n\t// Handle the error here\n\tconsole.error(err);\n});\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- A database library that supports promises (such as Sequelize)\n- Express.js for handling HTTP requests and responses\n- bcrypt for hashing passwords\n- A flash messaging library (such as connect-flash)\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "ccc3f7d3-17f7-3c2e-a1bf-d4b3c5003260",
              "name": "Unverified User Input IDOR Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnverified User Input IDOR (Insecure Direct Object References) Vulnerability is a type of security vulnerability that occurs when a function with no access control is used to access a specific resource directly. In the context of JavaScript, this vulnerability can occur when a user is able to manipulate input to access unauthorized data. In the provided code, the vulnerability lies in the fact that the user input is directly used to query the database without any validation or sanitization.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to implement proper access control checks and validate and sanitize all user inputs. Access control checks ensure that a user can only access data that they are authorized to access. Input validation and sanitization help to prevent malicious input from being executed as part of the query.\n\n## Source Code Fix Recommendation\n\n```javascript\nvar userId = parseInt(req.body.id, 10);\n\nif (isNaN(userId)) {\n    // Handle error\n} else {\n    db.User.find({\n        where: {\n            'id': userId\n        }\t\t\n    }).then(user => {\n        // ...\n    });\n}\n```\n\nIn the above code, the user input is first parsed into an integer. If the input is not a valid number, an error is handled. This helps to prevent malicious input from being executed as part of the query.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Express.js: A web application framework for Node.js.\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n\n## References\n\n- [OWASP Top 10-2017 A5-Broken Access Control](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control)\n- [CWE-285: Improper Authorization](https://cwe.mitre.org/data/definitions/285.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-285",
                    "url": "https://cwe.mitre.org/data/definitions/285.html"
                  },
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-285",
                  "CWE-89"
                ]
              }
            },
            {
              "id": "9e7f935e-1419-32f9-a5a8-faa28a812b45",
              "name": "\"Open Redirect Vulnerability in URL Building Application\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nOpen Redirect Vulnerability in URL Building Application is a security flaw in JavaScript applications that allows an attacker to redirect users to malicious websites. This vulnerability occurs when an application incorporates user input into a URL redirect without validating the input. In the provided code, the application redirects the user to the URL provided in the query string without any validation, which can be exploited by an attacker.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to avoid using user input directly in URL redirect functions. If it is necessary to use user input, it should be validated and sanitized before use. The application should only allow redirects to known, trusted URLs.\n\n## Source Code Fix Recommendation\n\n```javascript\n// Assuming express.js is used\nvar express = require('express');\nvar app = express();\n\napp.get('/redirect', function(req, res) {\n    var url = req.query.url;\n    // Validate the URL before redirecting\n    if (validateURL(url)) {\n        res.redirect(url);\n    } else {\n        // Handle invalid URL\n        res.redirect('/error');\n    }\n});\n\nfunction validateURL(url) {\n    // Implement URL validation logic here\n    // For example, check if the URL is in a list of trusted URLs\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- Express.js\n\n## References\n\n- [OWASP Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)\n- [CWE-601: URL Redirection to Untrusted Site ('Open Redirect')](https://cwe.mitre.org/data/definitions/601.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-601",
                    "url": "https://cwe.mitre.org/data/definitions/601.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-601"
                ]
              }
            },
            {
              "id": "de1c00f3-1236-30a1-858c-433ce6f12886",
              "name": "\"Deprecated mathjs.eval() is susceptible to code injection; use mathjs.evaluate() instead.\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `mathjs.eval()` function in the Math.js library is deprecated and is known to be susceptible to code injection attacks. This is a serious security vulnerability where an attacker can inject malicious code into the application, which is then executed by the application. This can lead to a variety of attacks, such as data theft, data corruption, denial of service, or even full system compromise.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to replace the deprecated `mathjs.eval()` function with the `mathjs.evaluate()` function, which is not susceptible to code injection attacks. \n\nAdditionally, it is always a good practice to validate and sanitize all user inputs to prevent code injection attacks. Never trust user input and always assume it could be malicious.\n\n## Source Code Fix Recommendation\n\nReplace the vulnerable code:\n\n```javascript\noutput: mathjs.eval(req.body.eqn)\n```\n\nWith the secure code:\n\n```javascript\noutput: mathjs.evaluate(req.body.eqn)\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n\n## References\n\n- [OWASP Code Injection](https://owasp.org/www-community/attacks/Code_Injection)\n- [CWE-94: Improper Control of Generation of Code ('Code Injection')](https://cwe.mitre.org/data/definitions/94.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-94",
                    "url": "https://cwe.mitre.org/data/definitions/94.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-94"
                ]
              }
            },
            {
              "id": "1e4caf67-5bfb-3038-9006-891aefedc48b",
              "name": "Unfiltered Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnfiltered Database Query Vulnerability in JavaScript is a security flaw that occurs when a developer does not properly sanitize or filter input data before using it in a database query. This can lead to SQL Injection attacks where an attacker can manipulate the query to gain unauthorized access to the database, modify the database, or even delete data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should always sanitize and validate input data before using it in a database query. This can be done by using parameterized queries or prepared statements, which separate the data from the query itself, making it impossible for an attacker to manipulate the query.\n\n## Source Code Fix Recommendation\n\nThe code example provided does not show any direct vulnerability to Unfiltered Database Query as it does not use any user input in the query. However, to ensure safety, it's recommended to use Sequelize's built-in protection against SQL Injection. Sequelize is an ORM for Node.js and it automatically escapes all input to prevent SQL Injection.\n\n```javascript\ndb.User.findAll({\n  where: {\n    // Add your conditions here\n  }\n}).then(users => {\n  // Your code here\n});\n```\n\n## Library Dependencies\n\nThe code example provided requires the following library dependencies:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n\n## References\n\n- [OWASP SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-89"
                ]
              }
            },
            {
              "id": "36d5f6a1-bad0-344e-8212-a75e96f906c7",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a Promise is rejected, but there is no error handling mechanism in place to catch and handle the error. This can lead to unexpected application behavior, crashes, and potential security vulnerabilities. In the provided code, the Promise returned by `db.User.findAll({})` is not being handled for a case where it might get rejected.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always handle Promise rejections by providing a `.catch()` block or by using `try/catch` with async/await. This allows you to handle any errors that occur during the execution of the Promise and prevent unexpected application behavior.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the provided code:\n\n```javascript\ndb.User.findAll({})\n  .then(users => {\n    res.status(200).json({\n      success: true,\n      users: users\n    });\n  })\n  .catch(err => {\n    console.error(err);\n    res.status(500).json({\n      success: false,\n      message: 'An error occurred while fetching users'\n    });\n  });\n```\n\nIn this fixed code, if the Promise returned by `db.User.findAll({})` is rejected, the `.catch()` block will handle the error, preventing the Unhandled Promise Rejection.\n\n## Library Dependencies\n\nThe provided code seems to be using the following libraries:\n\n- Sequelize (for `db.User.findAll({})`)\n- Express (for `res.status().json()`)\n\n## References\n\n- [OWASP Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "58d74204-e872-36aa-836d-ab10502a5418",
              "name": "Insecure Hashing Methods Detected",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Insecure Hashing Methods Detected\" is a vulnerability that arises when a weak cryptographic hash function is used in a JavaScript application. In this case, the MD5 hash function is being used, which is considered insecure due to its susceptibility to collision attacks. This means that two different inputs can produce the same hash output, which can lead to unauthorized access or data integrity issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a stronger hash function such as SHA-256 or SHA-3. These hash functions are currently considered secure and are not susceptible to collision attacks. Additionally, it is also recommended to use a salt in conjunction with the hash function to further increase security. A salt is a random value that is used as an additional input to the hash function to prevent precomputed hash attacks.\n\n## Source Code Fix Recommendation\n\nReplace the MD5 hash function with a stronger hash function such as SHA-256. Here is an example of how to do this using the `crypto` library in Node.js:\n\n```javascript\nvar crypto = require('crypto');\n\nfunction hash(input) {\n    return crypto.createHash('sha256').update(input).digest('hex');\n}\n```\n\n## Library Dependencies\n\nThe `crypto` library is built into Node.js, so no additional dependencies are required.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-327",
                    "url": "https://cwe.mitre.org/data/definitions/327.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-327"
                ]
              }
            },
            {
              "id": "ce987a29-92e0-3e8b-aff6-d07dc2295ee9",
              "name": "Unfiltered Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnfiltered Database Query Vulnerability, also known as NoSQL Injection, is a type of security vulnerability that occurs when an application does not properly validate or escape input before using it in a database query. This can allow an attacker to manipulate the query, potentially leading to unauthorized access to data, data corruption, or even data loss.\n\nIn the provided JavaScript code, the vulnerability lies in the fact that the `login` field from the request body is directly used in the database query without any validation or sanitization. This means that an attacker could potentially send a specially crafted request that manipulates the query.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always validate and sanitize user input before using it in a database query. This can be done using various methods, such as using prepared statements, parameterized queries, or ORM libraries that automatically handle these issues.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix using the `sequelize` library's built-in escaping mechanism:\n\n```javascript\ndb.User.find({\n    where: {\n        'login': sequelize.escape(req.body.login)\n    }\n}).then(user => {\n```\n\n## Library Dependencies\n\nThe provided code example seems to be using the `sequelize` library for interacting with the database and the `express` library for handling HTTP requests. Therefore, these libraries would be required for the code to execute properly.\n\n## References\n\n- [OWASP: Query Parameterization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html)\n- [OWASP: Injection Prevention Cheat Sheet in Java](https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet_in_Java.html)\n- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')](https://cwe.mitre.org/data/definitions/89.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-89",
                    "url": "https://cwe.mitre.org/data/definitions/89.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-89"
                ]
              }
            },
            {
              "id": "c5680213-67cb-3707-9b6c-1ce025528422",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a Promise is rejected, but there is no error handling mechanism in place to catch and handle the error. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information in error messages.\n\nIn the provided code, the Promise returned by `db.User.find()` is not handled properly. If the Promise is rejected (for example, if there is a problem connecting to the database), the error will not be caught and handled, and the application may crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle Promise rejections. This can be done by chaining a `.catch()` block to the Promise, which will catch and handle any errors that occur. The `.catch()` block should contain code to handle the error appropriately, such as logging the error and returning a response to the client indicating that an error occurred.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.User.find({\n\twhere: {\n\t\t'login': req.body.login\n\t}\n}).then(user => {\n\tif (user) {\n\t\t// Send reset link via email happens here\n\t\treq.flash('info', 'Check email for reset link')\n\t\tres.redirect('/login')\n\t} else {\n\t\treq.flash('danger', \"Invalid login username\")\n\t\tres.redirect('/forgotpw')\n\t}\n}).catch(err => {\n\t// Handle the error appropriately here\n\tconsole.error(err);\n\tres.status(500).send('An error occurred');\n});\n```\n\n## Library Dependencies\n\nThe provided code appears to require the following libraries:\n\n- A database library that provides the `db.User.find()` function. This could be Sequelize, for example.\n- Express.js, for handling HTTP requests and responses.\n- The `req.flash()` function suggests that the `connect-flash` middleware for Express.js is being used.\n\n## OWASP and CWE Links\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "7b866c05-60b3-3d40-8e2b-070af8617634",
              "name": "Unselected Field Database Query Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unselected Field Database Query Vulnerability\" in JavaScript is a security flaw that occurs when a developer does not explicitly define the fields to be returned from a database query. This can lead to the exposure of sensitive data. In the provided code, the `find` method is used to retrieve a user based on the `login` field. However, all fields associated with the user are returned, which may include sensitive data such as passwords or personal information.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, developers should explicitly define the fields to be returned from the database query. This can be done using the `attributes` option in the `find` method. By specifying only the necessary fields, developers can prevent the exposure of sensitive data.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.User.find({\n    attributes: ['login', 'other_field'], // specify the fields to be returned\n    where: {\n        'login': req.query.login\n    }\n}).then(user => {\n    // ...\n});\n```\n\nIn this code, only the `login` and `other_field` fields are returned from the database query.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- `sequelize`: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n- `express`: A fast, unopinionated, minimalist web framework for Node.js.\n\n## References\n\n- [OWASP - Query Parameterization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html)\n- [CWE-209: Information Exposure Through an Error Message](https://cwe.mitre.org/data/definitions/209.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-209",
                    "url": "https://cwe.mitre.org/data/definitions/209.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-209"
                ]
              }
            },
            {
              "id": "a7464f96-d4d8-381b-aa8b-37c31c0eb135",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but the rejection is not caught or handled. This can lead to unexpected application behavior, including crashes and unhandled exceptions. In the context of Node.js, an unhandled promise rejection can cause the Node.js process to terminate.\n\nIn the provided code, the promise returned by `db.User.find()` is not properly handled. If the promise is rejected (for example, if there is a problem connecting to the database), the rejection will not be caught and the application may crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle promise rejections. This can be done by adding a `.catch()` block to the promise chain. The `.catch()` block will be called if the promise is rejected.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the provided code:\n\n```javascript\ndb.User.find({\n\twhere: {\n\t\t'login': req.query.login\n\t}\n}).then(user => {\n\tif (user) {\n\t\tif (req.query.token == md5(req.query.login)) {\n\t\t\tres.render('resetpw', {\n\t\t\t\tlogin: req.query.login,\n\t\t\t\ttoken: req.query.token\n\t\t\t})\n\t\t} else {\n\t\t\treq.flash('danger', \"Invalid reset token\")\n\t\t\tres.redirect('/forgotpw')\n\t\t}\n\t} else {\n\t\treq.flash('danger', \"Invalid login username\")\n\t\tres.redirect('/forgotpw')\n\t}\n}).catch(err => {\n\t// Handle the error here\n\tconsole.error(err);\n\treq.flash('danger', \"An error occurred\")\n\tres.redirect('/forgotpw')\n});\n```\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- A database library that provides the `db.User.find()` method. This could be Sequelize, Mongoose, or a similar library.\n- Express.js, for handling HTTP requests and responses.\n- The `md5` library, for hashing the login.\n- A flash messaging library, such as `connect-flash`, for displaying flash messages.\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "a3f6ba1b-c210-312b-afdf-3a37df5cb479",
              "name": "Insecure Hashing Methods Detected: Upgrade to bcrypt, scrypt, Argon2, or SHA-256+ Required.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability \"Insecure Hashing Methods Detected: Upgrade to bcrypt, scrypt, Argon2, or SHA-256+ Required\" refers to the use of weak or insecure cryptographic hashing methods in JavaScript. In the provided code snippet, the MD5 hashing algorithm is used, which is considered insecure due to its susceptibility to collision attacks.\n\n## Mitigation\n\nTo mitigate this vulnerability, it is recommended to use a more secure hashing algorithm such as bcrypt, scrypt, Argon2, or SHA-256. These algorithms are designed to be computationally intensive, making them resistant to brute-force and rainbow table attacks.\n\n## Code Fix\n\nHere is a recommended fix using the bcrypt library:\n\n```javascript\nconst bcrypt = require('bcrypt');\n\n// ...\n\nbcrypt.compare(req.query.login, req.query.token, function(err, res) {\n    if(res) {\n     // Passwords match\n    } else {\n     // Passwords don't match\n    } \n});\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- bcrypt: A library to help you hash passwords.\n\n## References\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-327",
                    "url": "https://cwe.mitre.org/data/definitions/327.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-327"
                ]
              }
            },
            {
              "id": "83ca2a00-6d50-3d3c-b58c-b3ebbaadfd82",
              "name": "Unverified User Input IDOR Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnverified User Input IDOR (Insecure Direct Object References) Vulnerability is a type of security vulnerability that occurs when a function with no proper access control is used to access specific resources directly. In JavaScript, this vulnerability can occur when a user-supplied input is used directly to query a database without proper validation or authorization checks. This can allow an attacker to manipulate the input to gain unauthorized access to data.\n\nIn the provided code snippet, the application is using the user-supplied login name (`req.body.login`) directly to query the database for a user. If an attacker can guess or brute-force a valid login name, they can potentially gain unauthorized access to that user's data.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Always validate user-supplied inputs: Ensure that the input matches the expected format and length. This can help prevent SQL Injection attacks.\n\n2. Implement proper access control: Ensure that the user is authorized to access the requested resource. This can help prevent unauthorized access to data.\n\n3. Use parameterized queries or prepared statements: This can help prevent SQL Injection attacks by ensuring that user-supplied inputs are always treated as literal values, not part of the SQL command.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```javascript\n// Assuming Express.js and Sequelize ORM\napp.post('/login', (req, res) => {\n  // Validate input\n  if (!req.body.login || typeof req.body.login !== 'string' || req.body.login.length > 100) {\n    return res.status(400).send('Invalid login');\n  }\n\n  // Query database\n  db.User.find({\n    where: {\n      'login': req.body.login\n    }\n  }).then(user => {\n    // Check if user exists\n    if (!user) {\n      return res.status(404).send('User not found');\n    }\n\n    // Check if user is authorized to access the requested resource\n    if (req.session.userId !== user.id) {\n      return res.status(403).send('Unauthorized');\n    }\n\n    // Continue processing...\n  });\n});\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- Express.js: A web application framework for Node.js.\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n\n## References\n\n- [CWE-639: Authorization Bypass Through User-Controlled Key](https://cwe.mitre.org/data/definitions/639.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-639",
                    "url": "https://cwe.mitre.org/data/definitions/639.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-639"
                ]
              }
            },
            {
              "id": "cf96834b-e589-3399-b7af-68f942a5a2e7",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but the rejection is not caught or handled. This can lead to unexpected application behavior, including crashes and unhandled exceptions. In the provided code, if the `user.save()` promise is rejected, there is no error handling mechanism in place to catch and handle the rejection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always include a `.catch()` block when working with promises to handle any potential rejections. This allows you to define how your application should respond, preventing unexpected behavior and improving the robustness of your code.\n\n## Source Code Fix Recommendation\n\nHere is the fixed version of the code:\n\n```javascript\ndb.User.find({\n    where: {\n        'login': req.body.login\n    }\n}).then(user => {\n    if (user) {\n        if (req.body.token == md5(req.body.login)) {\n            user.password = bCrypt.hashSync(req.body.password, bCrypt.genSaltSync(10), null)\n            user.save().then(function () {\n                req.flash('success', \"Password successfully reset\")\n                res.redirect('/login')\n            }).catch(err => {\n                console.error(err);\n                req.flash('danger', \"An error occurred while resetting password\")\n                res.redirect('/forgotpw')\n            })\n        } else {\n            req.flash('danger', \"Invalid reset token\")\n            res.redirect('/forgotpw')\n        }\n    } else {\n        req.flash('danger', \"Invalid login username\")\n        res.redirect('/forgotpw')\n    }\n}).catch(err => {\n    console.error(err);\n    req.flash('danger', \"An error occurred while finding user\")\n    res.redirect('/forgotpw')\n})\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Sequelize (for `db.User.find()`)\n- Express.js (for `req`, `res`, `req.body`, `req.flash()`, `res.redirect()`)\n- bcryptjs (for `bCrypt.hashSync()`, `bCrypt.genSaltSync()`)\n- md5 (for `md5()`)\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "e3cfc2e2-c151-3215-951e-1e63bf9d4460",
              "name": "Insecure Hashing Methods Detected: MD5, SHA1 Inadequate for Security, bcrypt/scrypt/Argon2 and SHA-256+ Recommended.",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nInsecure hashing methods such as MD5 and SHA1 are considered inadequate for security due to their vulnerabilities to collision attacks. This means that two different inputs can produce the same hash output, making it easier for an attacker to guess the original input. In JavaScript programming, this vulnerability can occur when these insecure hashing methods are used for sensitive data like passwords or tokens.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use more secure hashing methods such as bcrypt, scrypt, Argon2, or SHA-256 or higher. These methods are designed to be computationally intensive and slow, making it much more difficult for an attacker to guess the original input.\n\n## Source Code Fix Recommendation\n\nReplace the MD5 hashing method with a more secure method. For example, if you are using the `crypto` library, you can use the `scrypt` method:\n\n```javascript\nconst crypto = require('crypto');\n\ncrypto.scrypt(req.body.login, 'salt', 64, (err, derivedKey) => {\n  if (err) throw err;\n  if (req.body.token == derivedKey.toString('hex')) {\n    // ...\n  }\n});\n```\n\nIn this example, 'salt' is a random value that is used to prevent rainbow table attacks. It should be unique per user and stored along with the hash.\n\n## Library Dependencies\n\nThe code example requires the `crypto` library, which is built into Node.js.\n\n## References\n\n- [OWASP - Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n- [OWASP - Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-327",
                    "url": "https://cwe.mitre.org/data/definitions/327.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-327"
                ]
              }
            },
            {
              "id": "9225247f-64c7-3daa-84ac-d02dd219a622",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but the rejection is not caught or handled. This can lead to unexpected application behavior and potential security vulnerabilities. In the provided code, if the promise returned by `db.User.findOne()` is rejected (for example, due to a database error), the rejection will not be caught and will result in an Unhandled Promise Rejection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle promise rejections. This can be done by adding a `.catch()` block to the promise chain, which will catch any errors that occur in the preceding `.then()` blocks. In the `.catch()` block, you can handle the error appropriately, for example by logging the error and returning a response indicating that an error occurred.\n\n## Source Code Fix Recommendation\n\nHere is how you can fix the provided code:\n\n```javascript\ndb.User.findOne({\n    where: {\n        'id': uid\n    }\n}).then(function (user) {\n    if (user) {\n        done(null, user);\n    } else {\n        done(null, false)\n    }\n}).catch(function (error) {\n    // Handle the error appropriately here\n    console.error(error);\n    done(error);\n});\n```\n\nIn this fixed code, if the promise is rejected, the `.catch()` block will catch the error, log it to the console, and call `done()` with the error.\n\n## Library Dependencies\n\nThe provided code appears to require the following library dependencies:\n\n- Sequelize (or a similar ORM library) for the `db.User.findOne()` function.\n- A library or framework that provides the `done()` function, such as Passport.js.\n\n## References\n\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "866313ba-f531-3b3a-acc7-36dbe347579d",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" in JavaScript occurs when a Promise is rejected, but this rejection is not caught or handled. This can lead to unexpected application behavior, including crashes, and can potentially expose sensitive information or lead to other security vulnerabilities.\n\nIn the provided code, the Promise returned by `db.User.findOne()` is not being handled for a case where it might get rejected. This could happen, for example, if there is a problem with the database connection or a query error.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always handle Promise rejections. This can be done by adding a `.catch()` block to the Promise chain, which will catch any errors that occur in the Promise or in any of the `.then()` blocks.\n\n## Source Code Fix Recommendation\n\nHere is how you could modify the provided code to handle Promise rejections:\n\n```javascript\ndb.User.findOne({\n    where: {\n        'login': username\n    }\n}).then(function (user) {\n    if (!user) {\n        return done(null, false, req.flash('danger', 'Invalid Credentials'))\n    }\n    if (!isValidPassword(user, password)) {\n        return done(null, false, req.flash('danger', 'Invalid Credentials'))\n    }\n    return done(null, user);\n}).catch(function (error) {\n    // Handle the error here\n    console.error(error);\n    return done(error);\n});\n```\n\nIn the `.catch()` block, you should handle the error appropriately for your application. This might involve logging the error, returning an error response, or retrying the operation, depending on the nature of the error and the requirements of your application.\n\n## Library Dependencies\n\nThe provided code appears to require the following libraries:\n\n- A database library that provides the `db.User.findOne()` function. This could be Sequelize, for example.\n- The `done` function, which is typically provided by Passport.js in the context of authentication.\n- The `req.flash()` function, which is provided by the `connect-flash` middleware for Express.js.\n\n## References\n\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "224b9ad3-a232-35a6-88cf-2bbd5fc79af5",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nUnhandled Promise Rejection Vulnerability in JavaScript occurs when a promise is rejected, but there is no error handling mechanism in place to catch and handle the error. This can lead to unexpected application behavior, including crashes and potential security vulnerabilities. In the provided code, the promise returned by `db.User.create()` is not handled properly. If the promise is rejected (for example, if there is a problem creating the user), the error will not be caught and handled, and the application may crash or behave unexpectedly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always have error handling mechanisms in place for promises. This can be done using `.catch()` blocks, or by using `try/catch` blocks with async/await. \n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\ndb.User.create({\n    email: req.body.email,\n    password: createHash(password),\n    name: req.body.name,\n    login: username\n}).then(function (user) {\n    return done(null, user)\n}).catch(function (error) {\n    // Handle the error here\n    console.error(error);\n    return done(error);\n});\n```\n\nIn this version of the code, if the promise returned by `db.User.create()` is rejected, the error will be caught and logged to the console, and the `done` callback will be called with the error.\n\n## Library Dependencies\n\nThe provided code appears to depend on the following libraries:\n\n- A database library that provides the `db.User.create()` method. This could be Sequelize, Mongoose, or a similar library.\n- A library or function that provides the `createHash()` function. This could be the `crypto` module in Node.js, or a similar library.\n- Express.js or a similar library for handling HTTP requests and responses (as indicated by the use of `req.body`).\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "f40d37bc-a799-33d2-976e-505fb388e17a",
              "name": "Unhandled Promise Rejection Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Unhandled Promise Rejection Vulnerability\" is a type of vulnerability in JavaScript that occurs when a promise is rejected, but there is no error handling mechanism in place to catch and handle the error. This can lead to unexpected application behavior, including crashes and potential security risks.\n\nIn the provided code, the `sequelize.authenticate()` function returns a promise. If the promise is rejected (for example, if the database connection fails), there is no `catch` block to handle the error. This can lead to an Unhandled Promise Rejection.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always include error handling when working with promises. This can be done by chaining a `catch` block to the promise, which will be executed if the promise is rejected. The `catch` block should contain code to handle the error appropriately.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the provided code:\n\n```javascript\nsequelize\n  .authenticate()\n  .then(function () {\n    console.log('Connection has been established successfully.');\n  })\n  .catch(function (err) {\n    console.error('Unable to connect to the database:', err);\n  });\n```\n\nIn this version of the code, if the promise returned by `sequelize.authenticate()` is rejected, the `catch` block will be executed, logging the error to the console.\n\n## Library Dependencies\n\nThe provided code requires the following library dependencies:\n\n- `sequelize`: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server.\n\n## References\n\n- [OWASP - Unhandled Promise Rejection](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_security_cheat_sheet.html#unhandled-promise-rejections)\n- [CWE-754: Improper Check for Unusual or Exceptional Conditions](https://cwe.mitre.org/data/definitions/754.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-754",
                    "url": "https://cwe.mitre.org/data/definitions/754.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-754"
                ]
              }
            },
            {
              "id": "073f2b99-5b1e-39a8-8ef2-1116fdbbfb79",
              "name": "\"Potential Out-of-Destination Writing Vulnerability\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nPotential Out-of-Destination Writing Vulnerability in JavaScript refers to a security flaw where an attacker can manipulate the path of a file or directory, allowing them to write or overwrite files outside of the intended destination. This can lead to unauthorized access to sensitive data, corruption of system files, or execution of malicious code.\n\nIn the provided code snippet, the vulnerability arises from the use of `sequelize.import()` function with a file path that could potentially be manipulated by an attacker.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to validate and sanitize all user inputs. Avoid using user-supplied input directly in file paths. If it's necessary to use user input in file paths, ensure that the path stays within the intended directory.\n\n## Source Code Fix Recommendation\n\n```javascript\nvar path = require('path');\nvar file = 'filename'; // Ensure this value is from a trusted source\n\nvar safePath = path.normalize(path.join(__dirname, file)).startsWith(path.normalize(__dirname));\n\nif (safePath) {\n  var model = sequelize.import(path.join(__dirname, file));\n} else {\n  console.error('Potential path manipulation detected');\n}\n```\n\nIn the above code, `path.normalize()` is used to resolve any '..' in the path, and `startsWith()` is used to ensure the path stays within the intended directory.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Sequelize: A promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite, and Microsoft SQL Server.\n- Path: A core Node.js module for handling and transforming file paths.\n\n## References\n\n- [OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)\n- [CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')](https://cwe.mitre.org/data/definitions/22.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-22",
                    "url": "https://cwe.mitre.org/data/definitions/22.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-22"
                ]
              }
            },
            {
              "id": "2992bbde-9c2e-361f-91b2-31865be4434c",
              "name": "\"Potential XSS Vulnerability from User-Controlled Data in HTML String\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Scripting (XSS) vulnerabilities occur when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, or redirect the user to malicious sites.\n\nIn the provided code, the application is vulnerable to XSS because it includes user-controlled data (`req.params.vuln`) in the HTML response without proper output encoding or validation.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. **Validate Input**: User input should be validated as strictly as possible on arrival, given the kind of content that it is expected to contain.\n2. **Encode Data**: User-controlled data included in the HTML response should be HTML entity encoded to prevent the browser from interpreting it as HTML/JavaScript code.\n3. **Use Appropriate Response Headers**: To prevent XSS in HTTP responses that aren't intended to contain any HTML or JavaScript, you can use the `Content-Type` and `X-Content-Type-Options` headers to ensure that browsers interpret the responses in the way you intend.\n4. **Content Security Policy**: Use Content Security Policy (CSP) to reduce the severity of any XSS vulnerabilities that still occur.\n\n## Source Code Fix\n\nThe Express.js framework provides a way to escape HTML through the `escape-html` module. Here is how you can use it:\n\n```javascript\nvar escapeHtml = require('escape-html');\n\nres.render('vulnerabilities/layout', {\n\tvuln: escapeHtml(req.params.vuln),\n\tvuln_title: vulnDict[escapeHtml(req.params.vuln)],\n\tvuln_scenario: escapeHtml(req.params.vuln) + '/scenario',\n\tvuln_description: escapeHtml(req.params.vuln) + '/description',\n\tvuln_reference: escapeHtml(req.params.vuln) + '/reference',\n\tvulnerabilities:vulnDict\n}, function (err, html) {\n\tif (err) {\n\t\tconsole.log(err)\n\t\tres.status(404).send('404')\n\t} else {\n\t\tres.send(html)\n\t}\n})\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- Express.js\n- escape-html\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "9dd77efa-9225-3872-a5ca-87b17ddcb5cd",
              "name": "Direct Writing to Response Object May Lead to XSS Vulnerability",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nCross-Site Scripting (XSS) is a type of injection security vulnerability typically found in web applications. XSS enables attackers to inject malicious scripts into web pages viewed by other users. A direct writing to response object vulnerability occurs when an application includes untrusted data in a new web page without proper validation or escaping, or updates an existing web page with user-supplied data using a browser API that can create HTML or JavaScript.\n\nIn the context of JavaScript programming, if you directly write user input to the response object, it may lead to an XSS vulnerability. For example, if you use `res.send(html)` where `html` is a string that includes user input, an attacker could inject malicious scripts into `html`.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always validate and sanitize user input. Never trust user input blindly. Use a secure method to generate HTML or JavaScript from user input. \n\n## Source Code Fix Recommendation\n\nInstead of using `res.send(html)`, use a template engine that automatically escapes user input, such as EJS or Pug. Here is an example using EJS:\n\n```javascript\nvar ejs = require('ejs');\n\n// ...\n\nvar html = ejs.render('<%= userContent %>', { userContent: userInput });\nres.send(html);\n```\n\nIn this example, `ejs.render` automatically escapes `userInput`, so it is safe to include in the response.\n\n## Library Dependencies\n\nThe code example requires the `ejs` library.\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [OWASP XSS (Cross Site Scripting) Prevention Cheat Sheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "b645aa4b-e8e1-33be-9761-d900b708a3ca",
              "name": "\"EJS Output Unescaped Vulnerability Allowing XSS Attacks\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nEJS (Embedded JavaScript) is a popular templating engine for JavaScript. It allows developers to generate HTML with plain JavaScript. However, it can be vulnerable to Cross-Site Scripting (XSS) attacks if not used properly. Specifically, the `<%- include(vuln_scenario) %>` syntax in EJS outputs unescaped HTML. This means that if `vuln_scenario` contains malicious script, it will be executed in the user's browser, leading to an XSS attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always escape user input that is rendered in the HTML. This can be done by using the `<%= %>` syntax in EJS, which outputs escaped HTML. \n\n## Source Code Fix Recommendation\n\nReplace `<%- include(vuln_scenario) %>` with `<%= include(vuln_scenario) %>`. \n\n## Library Dependencies\n\nThe code example requires the `ejs` library to execute properly.\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "e9e21afb-68e3-3247-ab33-4e782da01bc9",
              "name": "\"EJS Output Unescaped Vulnerability Allowing XSS Attacks\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nEJS (Embedded JavaScript) is a popular templating engine for JavaScript. It allows developers to generate HTML with plain JavaScript. However, it can be vulnerable to Cross-Site Scripting (XSS) attacks if not used properly. \n\nIn EJS, the `<%- %>` syntax is used to output unescaped HTML content. This means that any HTML or JavaScript code included in the variable will be executed when the page is loaded. If this variable is controlled by the user (for example, it comes from a form submission or URL parameter), an attacker could inject malicious scripts, leading to an XSS attack.\n\n## Mitigation Advice\n\nTo prevent XSS attacks, always escape user input that is included in the HTML output. In EJS, you can use the `<%= %>` syntax to output escaped HTML content. This will ensure that any HTML or JavaScript code included in the variable is displayed as plain text, not executed.\n\n## Source Code Fix Recommendation\n\nReplace the vulnerable code:\n\n```javascript\n<%- include(vuln_description) %>\n```\n\nWith the fixed code:\n\n```javascript\n<%= include(vuln_description) %>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            },
            {
              "id": "55c7a894-c974-3bc7-94b0-70273d620d6e",
              "name": "\"EJS Output Unescaped Vulnerability Allowing XSS Attacks\"",
              "helpUri": "https://www.glog.ai/",
              "help": {
                "text": "",
                "markdown": "## Description\n\nEJS (Embedded JavaScript) is a popular templating engine for JavaScript. It allows developers to generate HTML with plain JavaScript. However, it can be vulnerable to Cross-Site Scripting (XSS) attacks if not used properly. Specifically, the `<%- include(vuln_reference) %>` syntax in EJS outputs unescaped HTML. This means that if `vuln_reference` contains malicious script, it will be executed in the user's browser, leading to an XSS attack.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always escape user input that is rendered in the HTML. This can be done by using the `<%= include(vuln_reference) %>` syntax instead of `<%- include(vuln_reference) %>`. The `<%=` syntax automatically escapes HTML, preventing any scripts from being executed.\n\n## Source Code Fix Recommendation\n\nReplace:\n\n```javascript\n<%- include(vuln_reference) %>\n```\n\nwith:\n\n```javascript\n<%= include(vuln_reference) %>\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- EJS\n\n## References\n\n- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n- [CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')](https://cwe.mitre.org/data/definitions/79.html)"
              },
              "properties": {
                "cwe": [
                  {
                    "id": "CWE-79",
                    "url": "https://cwe.mitre.org/data/definitions/79.html"
                  }
                ],
                "severity": "MEDIUM",
                "kind": "FAIL",
                "tags": [
                  "CWE-79"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "20dbfa51-beb8-3d15-99f7-f93f54a67525",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 27,
                  "endLine": 49,
                  "endColumn": 30,
                  "charOffset": 1082,
                  "charLength": 3,
                  "snippet": {
                    "text": "md5",
                    "rendered": {
                      "text": "md5",
                      "markdown": "`md5`"
                    }
                  },
                  "sourceLanguage": "javascript"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "66b2b337e6438d894e2de00f04e6f4a409c5862d0351eaa3cd8bcb17621f52f6",
            "glog-pfp-ruleFileCode/v1": "b8d25b737b3b0ae857e1fd32e436ae8f3fad4816bce2c058204405aa5b259581"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "b8d25b737b3b0ae857e1fd32e436ae8f3fad4816bce2c058204405aa5b259581"
          },
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "core/authHandler.js"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1082,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "core/authHandler.js"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1082,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "c01f2e30-ff1e-354d-a93d-0454bcb3725f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Evaluation of Untrusted Data Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js"
                },
                "region": {
                  "startLine": 197,
                  "startColumn": 18,
                  "endLine": 198,
                  "endColumn": 4,
                  "charOffset": 4092,
                  "charLength": 23,
                  "snippet": {
                    "text": "eval(req.body.eqn)\n\t\t})",
                    "rendered": {
                      "text": "eval(req.body.eqn)\n\t\t})",
                      "markdown": "`eval(req.body.eqn)\n\t\t})`"
                    }
                  },
                  "sourceLanguage": "javascript"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2f7f9d49a3c5d376560fcab7887d866c106e50fd5b936328215e3e2f6efb782f",
            "glog-pfp-ruleFileCode/v1": "03b1185bb2b5f9cf188335dce08976365884112ee6bc669a4f96798afe1ace57"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "03b1185bb2b5f9cf188335dce08976365884112ee6bc669a4f96798afe1ace57"
          },
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Python.DangerousFunctionCall",
              "JavaScript.DangerousFunctionCall",
              "TypeScript.DangerousFunctionCall",
              "PHP.DangerousFunctionCall"
            ]
          }
        },
        {
          "ruleId": "21ea3123-3174-3d79-b784-74a27a5252e9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Postgresql Server Vulnerability to MITN Attacks due to Disabled TLS and Sequelize's Non-Enforcement of TLS\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "config/db.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 1,
                  "startColumn": 18,
                  "endLine": 8,
                  "endColumn": 2,
                  "snippet": {
                    "text": "module.exports = {\n  username: process.env.MYSQL_USER,\n  password: process.env.MYSQL_PASSWORD,\n  database: process.env.MYSQL_DATABASE,\n  host: process.env.MYSQL_HOST || 'mysql-db',\n  port: process.env.MYSQL_PORT || 3306,\n  dialect: 'mysql'\n}"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "18d42c0c0a3fd276b16c0ddc21cf987b591e2aff983815a6d35caa59e1f7545e",
            "glog-pfp-ruleFileCode/v1": "ec8b5d556822a64dc790d948eb569e9f826c707ed332fe5e8352d56b79ceb90e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ec8b5d556822a64dc790d948eb569e9f826c707ed332fe5e8352d56b79ceb90e"
          },
          "properties": {}
        },
        {
          "ruleId": "78935dac-7999-370f-871a-537b887d7db3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Validate user input before using in shell commands with imported child_process module."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 14,
                  "endLine": 3,
                  "endColumn": 43,
                  "snippet": {
                    "text": "const exec = require('child_process').exec;"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "abde2a07997b073144a245b5849a9aa2988b874034275368e20601117948dcd2",
            "glog-pfp-ruleFileCode/v1": "52e56ba6871681843d646d73e95b5c0967d96a4e1be859078e7e87ad6488e884"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "52e56ba6871681843d646d73e95b5c0967d96a4e1be859078e7e87ad6488e884"
          },
          "properties": {}
        },
        {
          "ruleId": "c5acd640-04b7-38a5-9c7a-0d8fd8be07d7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 27,
                  "endLine": 78,
                  "endColumn": 30,
                  "charOffset": 1815,
                  "charLength": 3,
                  "snippet": {
                    "text": "md5",
                    "rendered": {
                      "text": "md5",
                      "markdown": "`md5`"
                    }
                  },
                  "sourceLanguage": "javascript"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "abe0662902751f87588bf176c92920106fc6cd26649a57c8b1edc8805d4aa9bb",
            "glog-pfp-ruleFileCode/v1": "c7efde322d7c6f24a70e6a5b2a1c0ae22f474f348eb2a5e35c9f31542f8b94d6"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c7efde322d7c6f24a70e6a5b2a1c0ae22f474f348eb2a5e35c9f31542f8b94d6"
          },
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "core/authHandler.js"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1815,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "core/authHandler.js"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1815,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "b319a673-91d8-3d13-87d2-3721942851a7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Doubtful Remark"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js"
                },
                "region": {
                  "startLine": 216,
                  "startColumn": 4,
                  "endLine": 216,
                  "endColumn": 8,
                  "charOffset": 4436,
                  "charLength": 4,
                  "snippet": {
                    "text": "TODO",
                    "rendered": {
                      "text": "TODO",
                      "markdown": "`TODO`"
                    }
                  },
                  "sourceLanguage": "javascript"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "3e6031d2abe2247529877388749f9b7bf5771496dbe016170819f51624881a95",
            "glog-pfp-ruleFileCode/v1": "1786e4c9c7c3c20f5975529dec2bc61401fc71884bbad9edb461b7824a3f77f8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "1786e4c9c7c3c20f5975529dec2bc61401fc71884bbad9edb461b7824a3f77f8"
          },
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Comment.Suspicious"
            ]
          }
        },
        {
          "ruleId": "84b854a1-f34b-311e-ba56-c80d48d54711",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential SQL Injection Vulnerability Detected in Sequelize Statement"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 21,
                  "endLine": 11,
                  "endColumn": 26,
                  "snippet": {
                    "text": "\tdb.sequelize.query(query, {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "42398eb78168e98670087eae0e8695623926c8b2e10078775df0b1cc1ee3f3c1",
            "glog-pfp-ruleFileCode/v1": "87b73a15a053cbcad5a4c2ccd78d9d10e252a7a26519db3888b5d2918e8ec399"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "87b73a15a053cbcad5a4c2ccd78d9d10e252a7a26519db3888b5d2918e8ec399"
          },
          "properties": {}
        },
        {
          "ruleId": "9e7f935e-1419-32f9-a5a8-faa28a812b45",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unvalidated User-Supplied URL Redirection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 188,
                  "startColumn": 16,
                  "endLine": 188,
                  "endColumn": 29,
                  "snippet": {
                    "text": "\t\tres.redirect(req.query.url)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7f4ab984071a8244b8127951728d776f45cfba783aa9399325a2f442211f9d5f",
            "glog-pfp-ruleFileCode/v1": "3c1b5d011d0b9327e6ea70021b2a168489dfaac8037e7b63248dd618591616c8"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3c1b5d011d0b9327e6ea70021b2a168489dfaac8037e7b63248dd618591616c8"
          },
          "properties": {}
        },
        {
          "ruleId": "3b9b1a65-6df9-34c9-865c-92e11c2bd3f6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Remote Code Execution Vulnerability via Object Deserialization in serialize.unserialize Function\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 218,
                  "startColumn": 18,
                  "endLine": 218,
                  "endColumn": 81,
                  "snippet": {
                    "text": "\t\tvar products = serialize.unserialize(req.files.products.data.toString('utf8'))"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "19ca046e636ab9b91b643cee55596e145d0bb265b23cf4b159058965b1a59631",
            "glog-pfp-ruleFileCode/v1": "2694d78e333e86293e2ad230603d47ff2fc76d9837c4c6339fcc11b47ddfe9f1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2694d78e333e86293e2ad230603d47ff2fc76d9837c4c6339fcc11b47ddfe9f1"
          },
          "properties": {}
        },
        {
          "ruleId": "bab5710e-f80a-3d06-a815-795f80c5ba2a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Undetected CSRF Middleware in Your Express Application\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "server.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 5,
                  "endLine": 11,
                  "endColumn": 20,
                  "snippet": {
                    "text": "var app = express()"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c9bada67aa30b2f4eef499ae0ca4472c5112206f8b1f915f95e31c71920cec53",
            "glog-pfp-ruleFileCode/v1": "8f394d39a3ece33e72976fb1dd36c31432fd44642281eee517d4e079100167cc"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "8f394d39a3ece33e72976fb1dd36c31432fd44642281eee517d4e079100167cc"
          },
          "properties": {}
        },
        {
          "ruleId": "fd7234c9-f60f-32b7-86c2-9d3be0e45876",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"XML Parsing Library Found: Disable External Entity Resolution to Avoid XXE Attacks\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 5,
                  "startColumn": 16,
                  "endLine": 5,
                  "endColumn": 35,
                  "snippet": {
                    "text": "var libxmljs = require(\"libxmljs\");"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "35ca405e2b602d276a80f54dfee0bedd65c9b289ae9fbb8fee232202ffa70771",
            "glog-pfp-ruleFileCode/v1": "9b057744b126584e6bb10052a0411538274d1a964597897754ebc9ba040e5b24"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9b057744b126584e6bb10052a0411538274d1a964597897754ebc9ba040e5b24"
          },
          "properties": {}
        },
        {
          "ruleId": "f9220330-3239-30f0-bb86-58261d761080",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Libxml library's `noent` attribute set to `true` can lead to XXE vulnerabilities; recommended to set `noent` to `false` for protection.\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 235,
                  "startColumn": 42,
                  "endLine": 235,
                  "endColumn": 82,
                  "snippet": {
                    "text": "\t\tvar products = libxmljs.parseXmlString(req.files.products.data.toString('utf8'), {noent:true,noblanks:true})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "506d20d987043b34075880eda1b63471d7f1074d3ac7e003bcefc28ade497ce1",
            "glog-pfp-ruleFileCode/v1": "685ff32d21e97f81a6e7d48f0e43156a4b587aece4b9c62be0452da817ed68cc"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "685ff32d21e97f81a6e7d48f0e43156a4b587aece4b9c62be0452da817ed68cc"
          },
          "properties": {}
        },
        {
          "ruleId": "ba115ef7-d9a2-341d-83d4-44b83813a964",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Vulnerable Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 19,
                  "endLine": 3,
                  "endColumn": 22,
                  "charOffset": 80,
                  "charLength": 3,
                  "snippet": {
                    "text": "md5",
                    "rendered": {
                      "text": "md5",
                      "markdown": "`md5`"
                    }
                  },
                  "sourceLanguage": "javascript"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "0262fee5351cf229bf40037e7c5aec0b1ebf1c7c12948bfb616ae13e23f0ca33",
            "glog-pfp-ruleFileCode/v1": "4035756c14b67367ecfa83a13f88af445c69fabdf4cf4ebbd17b6d59dc942177"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "4035756c14b67367ecfa83a13f88af445c69fabdf4cf4ebbd17b6d59dc942177"
          },
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "core/authHandler.js"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 80,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "core/authHandler.js"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 80,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "d6457d2b-7a66-357e-8fae-e1e7b70dc714",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured Web Address"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/common/head.ejs"
                },
                "region": {
                  "startLine": 4,
                  "startColumn": 17,
                  "endLine": 4,
                  "endColumn": 48,
                  "charOffset": 144,
                  "charLength": 31,
                  "snippet": {
                    "text": "http://html5shim.googlecode.com",
                    "rendered": {
                      "text": "http://html5shim.googlecode.com",
                      "markdown": "`http://html5shim.googlecode.com`"
                    }
                  },
                  "sourceLanguage": "javascript"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "822d847710650e6c6d1c3c0bbf5d14a47bd606fc8ecbb11cdd82f3af459b6de1",
            "glog-pfp-ruleFileCode/v1": "bd01b04ed23facc46d0c0f9925597136f96fe7b29870dd1b0f9a694732adfd29"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "bd01b04ed23facc46d0c0f9925597136f96fe7b29870dd1b0f9a694732adfd29"
          },
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "views/common/head.ejs"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 144,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "https://html5shim.googlecode.com"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "1b1c4619-f040-3f90-9111-3ca724783e40",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential XSS Vulnerability from User-Controlled Data in HTML String\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 2,
                  "endLine": 10,
                  "endColumn": 78,
                  "snippet": {
                    "text": "\tvar query = \"SELECT name,id FROM Users WHERE login='\" + req.body.login + \"'\";"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "b32668493e03925996444b92fb90d5cde9dc44debd198f9800907690b28cf011",
            "glog-pfp-ruleFileCode/v1": "7e5bf8d25eec76ffb8d5ff898d3fd4aa3ed6a7c1b7c046c9c58010d6955d84ad"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7e5bf8d25eec76ffb8d5ff898d3fd4aa3ed6a7c1b7c046c9c58010d6955d84ad"
          },
          "properties": {}
        },
        {
          "ruleId": "c9476c0e-2a36-30ee-9141-e9d85491bb1a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Detected Vulnerability in node-serialize Library Allowing Arbitrary Code Execution\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 6,
                  "startColumn": 17,
                  "endLine": 6,
                  "endColumn": 42,
                  "snippet": {
                    "text": "var serialize = require(\"node-serialize\")"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "34b7748288889febaac2b2b37d68336d55da8b77ed3f3eee13a7be52cf685b56",
            "glog-pfp-ruleFileCode/v1": "ad2af618a441ea8a3639e5a89a8937cec04ea74cfec92bbea1ac0b6c042b4906"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ad2af618a441ea8a3639e5a89a8937cec04ea74cfec92bbea1ac0b6c042b4906"
          },
          "properties": {}
        },
        {
          "ruleId": "9dcfa863-6df2-331a-be98-ba857c5348e9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unsecured URL Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/vulnerabilities/a1_injection/description.ejs"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 1,
                  "endLine": 18,
                  "endColumn": 18,
                  "charOffset": 799,
                  "charLength": 18,
                  "snippet": {
                    "text": "http://example.com",
                    "rendered": {
                      "text": "http://example.com",
                      "markdown": "`http://example.com`"
                    }
                  },
                  "sourceLanguage": "javascript"
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "a5202385bc3820336a9c265849ea6d1db2d43b95b5b63772e5bcadf673ee0edc",
            "glog-pfp-ruleFileCode/v1": "927706c4598b8a367a5f203d1b5487759a2061c4cc069569249dc2e9915eeb1c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "927706c4598b8a367a5f203d1b5487759a2061c4cc069569249dc2e9915eeb1c"
          },
          "fixes": [
            {
              "description": {
                "text": "An HTTP-based URL without TLS was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "views/vulnerabilities/a1_injection/description.ejs"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 799,
                        "charLength": 18
                      },
                      "insertedContent": {
                        "text": "https://example.com"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "ThreatModel.Integration.HTTP"
            ]
          }
        },
        {
          "ruleId": "055908f0-60ec-34e2-99d7-df61704e3569",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Potential Path Traversal Vulnerability Detected in `path.join` or `path.resolve` Function Due to Unsanitized User Input"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "models/index.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 55,
                  "endLine": 43,
                  "endColumn": 59,
                  "snippet": {
                    "text": "    var model = sequelize.import(path.join(__dirname, file));"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2671bcbc7e8881ce5c1529fe88dd891e4cbac87e364e04e3a05c2e963d30d822",
            "glog-pfp-ruleFileCode/v1": "27e83a190480a1c312ee9a23c21e82a9624a93f28f30257982d4be2e28bef2f4"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "27e83a190480a1c312ee9a23c21e82a9624a93f28f30257982d4be2e28bef2f4"
          },
          "properties": {}
        },
        {
          "ruleId": "af01a7ee-caac-33b0-a917-bfcfb3bce866",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Default Session Cookie Name Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "server.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 23,
                  "startColumn": 9,
                  "endLine": 28,
                  "endColumn": 3,
                  "snippet": {
                    "text": "app.use(session({\n  secret: 'keyboard cat',\n  resave: true,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}))"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ce69d2a7144ea24780ebefb0c1d53009b4b8f096808c202427ea7f2041b69b5c",
            "glog-pfp-ruleFileCode/v1": "d21428b5890bf74121f88ea5d0dc24ff6cf37e815752d7022165f97561f53cd6"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "d21428b5890bf74121f88ea5d0dc24ff6cf37e815752d7022165f97561f53cd6"
          },
          "properties": {}
        },
        {
          "ruleId": "0960e248-84d3-3502-bcd0-541e59f5ebba",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "SQL Injection Risk from Untrusted Input and Raw SQL Query Concatenation"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 10,
                  "startColumn": 2,
                  "endLine": 35,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tvar query = \"SELECT name,id FROM Users WHERE login='\" + req.body.login + \"'\";\n\tdb.sequelize.query(query, {\n\t\tmodel: db.User\n\t}).then(user => {\n\t\tif (user.length) {\n\t\t\tvar output = {\n\t\t\t\tuser: {\n\t\t\t\t\tname: user[0].name,\n\t\t\t\t\tid: user[0].id\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.render('app/usersearch', {\n\t\t\t\toutput: output\n\t\t\t})\n\t\t} else {\n\t\t\treq.flash('warning', 'User not found')\n\t\t\tres.render('app/usersearch', {\n\t\t\t\toutput: null\n\t\t\t})\n\t\t}\n\t}).catch(err => {\n\t\treq.flash('danger', 'Internal Error')\n\t\tres.render('app/usersearch', {\n\t\t\toutput: null\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1085e92bf69b313df40ac8e2e1a276eec8450da2d9485c79ec8d712781dd948a",
            "glog-pfp-ruleFileCode/v1": "5d54b6e7f38b5e6f22b7b077ffbefaa28ebd245c2076a41e5fa35839f111e210"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "5d54b6e7f38b5e6f22b7b077ffbefaa28ebd245c2076a41e5fa35839f111e210"
          },
          "properties": {}
        },
        {
          "ruleId": "d20ba9e2-94ee-370c-9227-db01ee13e9a0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Hard-Coded Credential Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "server.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 24,
                  "startColumn": 3,
                  "endLine": 24,
                  "endColumn": 25,
                  "snippet": {
                    "text": "  secret: 'keyboard cat',"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "fc790f145993a88de1a5aa0e57223726c800a5a7e7b13118b6a333d986b0f238",
            "glog-pfp-ruleFileCode/v1": "c336c57472dc474291c203356374d2853f35243da865c207e215cf156512c387"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c336c57472dc474291c203356374d2853f35243da865c207e215cf156512c387"
          },
          "properties": {}
        },
        {
          "ruleId": "31813b77-cfad-3bb8-8371-b438a70a3e1b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 11,
                  "startColumn": 2,
                  "endLine": 30,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.sequelize.query(query, {\n\t\tmodel: db.User\n\t}).then(user => {\n\t\tif (user.length) {\n\t\t\tvar output = {\n\t\t\t\tuser: {\n\t\t\t\t\tname: user[0].name,\n\t\t\t\t\tid: user[0].id\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.render('app/usersearch', {\n\t\t\t\toutput: output\n\t\t\t})\n\t\t} else {\n\t\t\treq.flash('warning', 'User not found')\n\t\t\tres.render('app/usersearch', {\n\t\t\t\toutput: null\n\t\t\t})\n\t\t}\n\t}).catch(err => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c5b64d1e95afdc96ec94817996ed9fa4919913e89c2ea399839d1df707c6f6ba",
            "glog-pfp-ruleFileCode/v1": "f9fef2ccfc298a4c54522af0242213e466f561d56f874dbfba068ddaadd44679"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f9fef2ccfc298a4c54522af0242213e466f561d56f874dbfba068ddaadd44679"
          },
          "properties": {}
        },
        {
          "ruleId": "a46d83fc-ded8-3469-8316-e0528591d6d3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 71,
                  "endLine": 20,
                  "endColumn": 95,
                  "snippet": {
                    "text": "                Listing products with <strong>search query: </strong> <%- output.searchTerm %>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "993cce01512140422849249323195d439a005b4b58a35d471011c01600017e9a",
            "glog-pfp-ruleFileCode/v1": "0e9cccdc992c79010607886b7d65d2e97cdb61884eb2eee736f32b59bb35abd5"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0e9cccdc992c79010607886b7d65d2e97cdb61884eb2eee736f32b59bb35abd5"
          },
          "properties": {}
        },
        {
          "ruleId": "90408b14-a210-379b-a93e-9fa7a1965540",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 21,
                  "endLine": 49,
                  "endColumn": 49,
                  "snippet": {
                    "text": "                <td><%- output.products[i].id %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "4599dd340bf56d897d52f230329a557b79cb97e86a3f98364657481c8f35c407",
            "glog-pfp-ruleFileCode/v1": "3123ded679437e1954d4b7f0a1acff93f7c33600ccabe1ba71a78adfc840e081"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3123ded679437e1954d4b7f0a1acff93f7c33600ccabe1ba71a78adfc840e081"
          },
          "properties": {}
        },
        {
          "ruleId": "266a70bf-e91c-31bb-8b33-7be81335992b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 21,
                  "endLine": 50,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                <td><%- output.products[i].name %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e11211defbe7ebd1814bc865b8d48d6499771aff0028cbd96c689144ce449e63",
            "glog-pfp-ruleFileCode/v1": "280392f0b9a5a25c1b8b8f8dc3b63ae648666f8e0fa02d10d2ddc1fce8eaedeb"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "280392f0b9a5a25c1b8b8f8dc3b63ae648666f8e0fa02d10d2ddc1fce8eaedeb"
          },
          "properties": {}
        },
        {
          "ruleId": "6b3d767a-cfe7-3b6c-87d8-4ff57074985f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Command Injection Vulnerability through User Input Concatenation\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 2,
                  "endLine": 44,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\texec('ping -c 2 ' + req.body.address, function (err, stdout, stderr) {\n\t\toutput = stdout + stderr\n\t\tres.render('app/ping', {\n\t\t\toutput: output\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c836ff7ece7e99e795ec649e9e58181c3588075e173dfdbe9ae7c1a22a4a3918",
            "glog-pfp-ruleFileCode/v1": "b7a24f6ff425db4bbceebd025a0f58b4f690c00485f0ff5bb94f3b1368856e86"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "b7a24f6ff425db4bbceebd025a0f58b4f690c00485f0ff5bb94f3b1368856e86"
          },
          "properties": {}
        },
        {
          "ruleId": "2a87e4aa-7bb1-34b0-9997-53cf7be00f72",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 21,
                  "endLine": 51,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                <td><%- output.products[i].code %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "f68139076127b27a901c42af24d89e06e61541388985b8b0dad6824951912fa3",
            "glog-pfp-ruleFileCode/v1": "3525ed1ff18117443a2d2c3ff0c386dbf5000b2c4f8a1ec31a81cbf06ac9d92b"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "3525ed1ff18117443a2d2c3ff0c386dbf5000b2c4f8a1ec31a81cbf06ac9d92b"
          },
          "properties": {}
        },
        {
          "ruleId": "a8c344fb-e0b9-3bd0-beba-bc74b30a9708",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 21,
                  "endLine": 52,
                  "endColumn": 51,
                  "snippet": {
                    "text": "                <td><%- output.products[i].tags %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "1afa7e9f36e186fd802d95bbc8636c5ae0c00de7c39a40d00e4e0c03c31b2e5d",
            "glog-pfp-ruleFileCode/v1": "33c53a6479372986ae56ac256ea71bae7bfa25af72411647756a8b80c8f51c9a"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "33c53a6479372986ae56ac256ea71bae7bfa25af72411647756a8b80c8f51c9a"
          },
          "properties": {}
        },
        {
          "ruleId": "45081c46-bcda-384a-96d1-9d48f46fb46a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "EJS Template XSS Vulnerability Detected Due to Unescaped External Data"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/app/products.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 53,
                  "startColumn": 21,
                  "endLine": 53,
                  "endColumn": 58,
                  "snippet": {
                    "text": "                <td><%- output.products[i].description %></td>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "10ff96811314b638ff52e3b999b576d6a645f52fcbc1cfd0a329e3e99acfe70b",
            "glog-pfp-ruleFileCode/v1": "02e3cc1569b79b040e42aaa8412933d32fbd2ba308b25d1f1f73470405180e24"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "02e3cc1569b79b040e42aaa8412933d32fbd2ba308b25d1f1f73470405180e24"
          },
          "properties": {}
        },
        {
          "ruleId": "7e2b05b3-38c9-35ad-9929-bf922d0085db",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 2,
                  "endLine": 48,
                  "endColumn": 22,
                  "snippet": {
                    "text": "\tdb.Product.findAll().then(products => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "caf6d4570f6b157334a62b557dfd5df1ea4fee4dd1b463172f98cde070607721",
            "glog-pfp-ruleFileCode/v1": "cbdf47c63de4f63e7b58d975a1e21b95916c9a7c45cf594cd5b37a15151329e1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "cbdf47c63de4f63e7b58d975a1e21b95916c9a7c45cf594cd5b37a15151329e1"
          },
          "properties": {}
        },
        {
          "ruleId": "c8d00ddc-cb2f-3386-8938-1060a8e7a487",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 2,
                  "endLine": 55,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.Product.findAll().then(products => {\n\t\toutput = {\n\t\t\tproducts: products\n\t\t}\n\t\tres.render('app/products', {\n\t\t\toutput: output\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "73310be0d62f3dfc78d1ff16fcb864e4b104e73b4c67aacf6850f14a716b919b",
            "glog-pfp-ruleFileCode/v1": "f7475cc8c516f142e3f7b3bfb85bc6429b47d254afcce12486e6e00f11d42473"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f7475cc8c516f142e3f7b3bfb85bc6429b47d254afcce12486e6e00f11d42473"
          },
          "properties": {}
        },
        {
          "ruleId": "caa78969-106f-30a0-815f-8634d1d554c0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 2,
                  "endLine": 65,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.Product.findAll({\n\t\twhere: {\n\t\t\tname: {\n\t\t\t\t[Op.like]: '%' + req.body.name + '%'\n\t\t\t}\n\t\t}\n\t}).then(products => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "9f759e30d4eeeacf1d39668182e6cc6848cc0a6146914b736979c912b91ed97c",
            "glog-pfp-ruleFileCode/v1": "0549d55724c181763ab5318ed115164d719bff75d6b5fe8b76241f07213cc455"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0549d55724c181763ab5318ed115164d719bff75d6b5fe8b76241f07213cc455"
          },
          "properties": {}
        },
        {
          "ruleId": "d956d5d7-fa6d-32d3-9cd0-0b60c5231067",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 2,
                  "endLine": 73,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.Product.findAll({\n\t\twhere: {\n\t\t\tname: {\n\t\t\t\t[Op.like]: '%' + req.body.name + '%'\n\t\t\t}\n\t\t}\n\t}).then(products => {\n\t\toutput = {\n\t\t\tproducts: products,\n\t\t\tsearchTerm: req.body.name\n\t\t}\n\t\tres.render('app/products', {\n\t\t\toutput: output\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "bfa71a8174f21d74aa29f178623cfeb94b3b482472d0d439940538a0671362d6",
            "glog-pfp-ruleFileCode/v1": "20d2d5415d7345438ef551832b5378d123b27b512c818cf5e44a418b55a0bd9e"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "20d2d5415d7345438ef551832b5378d123b27b512c818cf5e44a418b55a0bd9e"
          },
          "properties": {}
        },
        {
          "ruleId": "0e6fc9e5-03de-37aa-af56-1faa4c6e245a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 3,
                  "endLine": 89,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.Product.find({\n\t\t\twhere: {\n\t\t\t\t'id': req.query.id\n\t\t\t}\n\t\t}).then(product => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "244f1bd534f117bd3919e03ca082d002d1c269c5c8b34f7047798105d0b2b395",
            "glog-pfp-ruleFileCode/v1": "fcc624b36569d012b9a6eef2003473a1b6efc7f61f61dcf94e2d4d638fd69bfd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "fcc624b36569d012b9a6eef2003473a1b6efc7f61f61dcf94e2d4d638fd69bfd"
          },
          "properties": {}
        },
        {
          "ruleId": "3f9d0612-751a-37dd-91b8-d38a6efa8402",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 3,
                  "endLine": 99,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.Product.find({\n\t\t\twhere: {\n\t\t\t\t'id': req.query.id\n\t\t\t}\n\t\t}).then(product => {\n\t\t\tif (!product) {\n\t\t\t\tproduct = {}\n\t\t\t}\n\t\t\toutput = {\n\t\t\t\tproduct: product\n\t\t\t}\n\t\t\tres.render('app/modifyproduct', {\n\t\t\t\toutput: output\n\t\t\t})\n\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "a54a8c352c2e2d3ae6622d66d25fa24e36609c89630a6bec97f0c91c16836faf",
            "glog-pfp-ruleFileCode/v1": "a6c89ad6c1d971385e6deffcc4d7e1729e59bb809993223512e2081d2789bbfa"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "a6c89ad6c1d971385e6deffcc4d7e1729e59bb809993223512e2081d2789bbfa"
          },
          "properties": {}
        },
        {
          "ruleId": "62bc3e5d-aa43-36a8-9c56-36406f37f48a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 2,
                  "endLine": 111,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.Product.find({\n\t\twhere: {\n\t\t\t'id': req.body.id\n\t\t}\n\t}).then(product => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e539eca08d5e8acd6c37edaf7f662a137353aa82d0cebf4336ec53015204c0b4",
            "glog-pfp-ruleFileCode/v1": "6f70bb3095b5dbdf1ab64d1eb803299e688d24b057ef355cee89cfc8ebf960a2"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "6f70bb3095b5dbdf1ab64d1eb803299e688d24b057ef355cee89cfc8ebf960a2"
          },
          "properties": {}
        },
        {
          "ruleId": "fdc73081-90fc-38f0-8464-db9b877e8c76",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 119,
                  "startColumn": 3,
                  "endLine": 124,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tproduct.save().then(p => {\n\t\t\tif (p) {\n\t\t\t\treq.flash('success', 'Product added/modified!')\n\t\t\t\tres.redirect('/app/products')\n\t\t\t}\n\t\t}).catch(err => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "581408cb4a01c77663ce1b06169c91ddba80bc45f13dcb775e8aad39f4547396",
            "glog-pfp-ruleFileCode/v1": "a73791e11dd3af187d5e0f09b3a5ffc0dd3000d389081080adce8dde2a13b935"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "a73791e11dd3af187d5e0f09b3a5ffc0dd3000d389081080adce8dde2a13b935"
          },
          "properties": {}
        },
        {
          "ruleId": "ccc3f7d3-17f7-3c2e-a1bf-d4b3c5003260",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 2,
                  "endLine": 149,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.User.find({\n\t\twhere: {\n\t\t\t'id': req.body.id\n\t\t}\t\t\n\t}).then(user =>{"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "cd7f31aba4c9b49ea9f41d97d7baa29165d4189d8fb2db32689f50ffbe3620de",
            "glog-pfp-ruleFileCode/v1": "d45ec6e43b1cf3982921b803fe90ebd8820d669ff4ff76584e5949c9d7381625"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "d45ec6e43b1cf3982921b803fe90ebd8820d669ff4ff76584e5949c9d7381625"
          },
          "properties": {}
        },
        {
          "ruleId": "15724e00-e71c-3b1d-906e-22bafe0e35de",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 2,
                  "endLine": 183,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.User.find({\n\t\twhere: {\n\t\t\t'id': req.body.id\n\t\t}\t\t\n\t}).then(user =>{\n\t\tif(req.body.password.length>0){\n\t\t\tif(req.body.password.length>0){\n\t\t\t\tif (req.body.password == req.body.cpassword) {\n\t\t\t\t\tuser.password = bCrypt.hashSync(req.body.password, bCrypt.genSaltSync(10), null)\n\t\t\t\t}else{\n\t\t\t\t\treq.flash('warning', 'Passwords dont match')\n\t\t\t\t\tres.render('app/useredit', {\n\t\t\t\t\t\tuserId: req.user.id,\n\t\t\t\t\t\tuserEmail: req.user.email,\n\t\t\t\t\t\tuserName: req.user.name,\n\t\t\t\t\t})\n\t\t\t\t\treturn\t\t\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treq.flash('warning', 'Invalid Password')\n\t\t\t\tres.render('app/useredit', {\n\t\t\t\t\tuserId: req.user.id,\n\t\t\t\t\tuserEmail: req.user.email,\n\t\t\t\t\tuserName: req.user.name,\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tuser.email = req.body.email\n\t\tuser.name = req.body.name\n\t\tuser.save().then(function () {\n\t\t\treq.flash('success',\"Updated successfully\")\n\t\t\tres.render('app/useredit', {\n\t\t\t\tuserId: req.body.id,\n\t\t\t\tuserEmail: req.body.email,\n\t\t\t\tuserName: req.body.name,\n\t\t\t})\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7ce8e7788adeffef3664f2e40cd75cd71f9e5a9ae3e46b28542c6eacec0ab769",
            "glog-pfp-ruleFileCode/v1": "f3d010e7da0e81c1be5bb2f494c75bce202bceb1c718f854b5165cc767272a04"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f3d010e7da0e81c1be5bb2f494c75bce202bceb1c718f854b5165cc767272a04"
          },
          "properties": {}
        },
        {
          "ruleId": "de1c00f3-1236-30a1-858c-433ce6f12886",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Code Injection Vulnerability Detected\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 197,
                  "startColumn": 12,
                  "endLine": 197,
                  "endColumn": 37,
                  "snippet": {
                    "text": "\t\t\toutput: mathjs.eval(req.body.eqn)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "2f2e58053cbb67ba42ac007cae9978f34f32cba101be5d31d28d20d31c210bfd",
            "glog-pfp-ruleFileCode/v1": "04f41ca4d0876366afc8cf1edad5f771d4b67884aabb035913e696943ea3320c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "04f41ca4d0876366afc8cf1edad5f771d4b67884aabb035913e696943ea3320c"
          },
          "properties": {}
        },
        {
          "ruleId": "1e4caf67-5bfb-3038-9006-891aefedc48b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unfiltered Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 2,
                  "endLine": 207,
                  "endColumn": 21,
                  "snippet": {
                    "text": "\tdb.User.findAll({}).then(users => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "fc7eff1cac5e8f14f3bb944c0af52bec5324c25717b746b5de42c14069171821",
            "glog-pfp-ruleFileCode/v1": "c68d9a4cfec36cf72f2dca9411b85b914512cb16a5795afd2074abd864d06442"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c68d9a4cfec36cf72f2dca9411b85b914512cb16a5795afd2074abd864d06442"
          },
          "properties": {}
        },
        {
          "ruleId": "36d5f6a1-bad0-344e-8212-a75e96f906c7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/appHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 207,
                  "startColumn": 2,
                  "endLine": 212,
                  "endColumn": 4,
                  "snippet": {
                    "text": "\tdb.User.findAll({}).then(users => {\n\t\tres.status(200).json({\n\t\t\tsuccess: true,\n\t\t\tusers: users\n\t\t})\n\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "c64a7e19f12582c998ff8a54e976b96bba6aac09737c3d252c52706026b0a5c2",
            "glog-pfp-ruleFileCode/v1": "dbebb86eaac74c503baeca7bda62bf65c97943a680c476843bc3026373e8ec14"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "dbebb86eaac74c503baeca7bda62bf65c97943a680c476843bc3026373e8ec14"
          },
          "properties": {}
        },
        {
          "ruleId": "58d74204-e872-36aa-836d-ab10502a5418",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Insecure Hashing Methods Detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 3,
                  "startColumn": 11,
                  "endLine": 3,
                  "endColumn": 25,
                  "snippet": {
                    "text": "var md5 = require('md5')"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "26cb90b1bfe6e22e5adba0997ee91178f76882ac7ec1db32db7721df0a507796",
            "glog-pfp-ruleFileCode/v1": "0c1af6346e1a198a566ee247b60628a88da636516243fff1e89c05c2ac0e9715"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0c1af6346e1a198a566ee247b60628a88da636516243fff1e89c05c2ac0e9715"
          },
          "properties": {}
        },
        {
          "ruleId": "ce987a29-92e0-3e8b-aff6-d07dc2295ee9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unverified User Input IDOR Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 3,
                  "endLine": 25,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.User.find({\n\t\t\twhere: {\n\t\t\t\t'login': req.body.login\n\t\t\t}\n\t\t}).then(user => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "9043b1d984a1019c3e7303bc7c5411099f5c0715205f13a85a0e25be36279848",
            "glog-pfp-ruleFileCode/v1": "c40bbdd5a62dd677ebb961ca1df3ad90ea1911e18a40be0bca87fdba66dc29a1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "c40bbdd5a62dd677ebb961ca1df3ad90ea1911e18a40be0bca87fdba66dc29a1"
          },
          "properties": {}
        },
        {
          "ruleId": "c5680213-67cb-3707-9b6c-1ce025528422",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 21,
                  "startColumn": 3,
                  "endLine": 34,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.User.find({\n\t\t\twhere: {\n\t\t\t\t'login': req.body.login\n\t\t\t}\n\t\t}).then(user => {\n\t\t\tif (user) {\n\t\t\t\t// Send reset link via email happens here\n\t\t\t\treq.flash('info', 'Check email for reset link')\n\t\t\t\tres.redirect('/login')\n\t\t\t} else {\n\t\t\t\treq.flash('danger', \"Invalid login username\")\n\t\t\t\tres.redirect('/forgotpw')\n\t\t\t}\n\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "18044355b1f701cdc533935d3c8f64ae8778ecabddb2d16eb05daea292c65250",
            "glog-pfp-ruleFileCode/v1": "7b84b6a0ae6ac2c8b009b5e41413a8fab62c1d453288032faf9a803e775bb9e1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7b84b6a0ae6ac2c8b009b5e41413a8fab62c1d453288032faf9a803e775bb9e1"
          },
          "properties": {}
        },
        {
          "ruleId": "7b866c05-60b3-3d40-8e2b-070af8617634",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unselected Field Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 3,
                  "endLine": 47,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.User.find({\n\t\t\twhere: {\n\t\t\t\t'login': req.query.login\n\t\t\t}\n\t\t}).then(user => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5907561c300b28b36bdc892914107701ff615f056b40ee9a13c086fe5fcc51cd",
            "glog-pfp-ruleFileCode/v1": "0f4a199e1ce3bf5b437c7f7e893a7b7240ac7a150d5450d95a95b3f1012751f7"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0f4a199e1ce3bf5b437c7f7e893a7b7240ac7a150d5450d95a95b3f1012751f7"
          },
          "properties": {}
        },
        {
          "ruleId": "a7464f96-d4d8-381b-aa8b-37c31c0eb135",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 3,
                  "endLine": 62,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tdb.User.find({\n\t\t\twhere: {\n\t\t\t\t'login': req.query.login\n\t\t\t}\n\t\t}).then(user => {\n\t\t\tif (user) {\n\t\t\t\tif (req.query.token == md5(req.query.login)) {\n\t\t\t\t\tres.render('resetpw', {\n\t\t\t\t\t\tlogin: req.query.login,\n\t\t\t\t\t\ttoken: req.query.token\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\treq.flash('danger', \"Invalid reset token\")\n\t\t\t\t\tres.redirect('/forgotpw')\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treq.flash('danger', \"Invalid login username\")\n\t\t\t\tres.redirect('/forgotpw')\n\t\t\t}\n\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "ba46914313d3cdde3a6cf3a8251c9de85cda981d9cdf78f3c12c300aa3aef2b2",
            "glog-pfp-ruleFileCode/v1": "7b4a39325450bfa889052351abe3f48ae43c0f95cb7a09c32fdd4d2c6f0c7b03"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7b4a39325450bfa889052351abe3f48ae43c0f95cb7a09c32fdd4d2c6f0c7b03"
          },
          "properties": {}
        },
        {
          "ruleId": "a3f6ba1b-c210-312b-afdf-3a37df5cb479",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Insecure Hashing Methods Detected: Upgrade to bcrypt, scrypt, Argon2, or SHA-256+ Required."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 28,
                  "endLine": 49,
                  "endColumn": 48,
                  "snippet": {
                    "text": "\t\t\t\tif (req.query.token == md5(req.query.login)) {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "531bc27dc9d1b504621dde6e63a432404ba0ce8faf7f837f2d400c22177b7424",
            "glog-pfp-ruleFileCode/v1": "0457e1158e1e732c66d8ca32656ad1a9297d63ebf5bf598c1c2a59920833dc8c"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "0457e1158e1e732c66d8ca32656ad1a9297d63ebf5bf598c1c2a59920833dc8c"
          },
          "properties": {}
        },
        {
          "ruleId": "83ca2a00-6d50-3d3c-b58c-b3ebbaadfd82",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unfiltered Database Query Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 4,
                  "endLine": 76,
                  "endColumn": 6,
                  "snippet": {
                    "text": "\t\t\tdb.User.find({\n\t\t\t\twhere: {\n\t\t\t\t\t'login': req.body.login\n\t\t\t\t}\n\t\t\t}).then(user => {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "cc03baa18480cc562095135117fc601ca94f761037a179794ae2d07224d681f5",
            "glog-pfp-ruleFileCode/v1": "f33953a98bac0e1a2f0fd016e70f086d816ad181e41c960e3c34c7a86baed678"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "f33953a98bac0e1a2f0fd016e70f086d816ad181e41c960e3c34c7a86baed678"
          },
          "properties": {}
        },
        {
          "ruleId": "cf96834b-e589-3399-b7af-68f942a5a2e7",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 4,
                  "endLine": 92,
                  "endColumn": 6,
                  "snippet": {
                    "text": "\t\t\tdb.User.find({\n\t\t\t\twhere: {\n\t\t\t\t\t'login': req.body.login\n\t\t\t\t}\n\t\t\t}).then(user => {\n\t\t\t\tif (user) {\n\t\t\t\t\tif (req.body.token == md5(req.body.login)) {\n\t\t\t\t\t\tuser.password = bCrypt.hashSync(req.body.password, bCrypt.genSaltSync(10), null)\n\t\t\t\t\t\tuser.save().then(function () {\n\t\t\t\t\t\t\treq.flash('success', \"Passowrd successfully reset\")\n\t\t\t\t\t\t\tres.redirect('/login')\n\t\t\t\t\t\t})\n\t\t\t\t\t} else {\n\t\t\t\t\t\treq.flash('danger', \"Invalid reset token\")\n\t\t\t\t\t\tres.redirect('/forgotpw')\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treq.flash('danger', \"Invalid login username\")\n\t\t\t\t\tres.redirect('/forgotpw')\n\t\t\t\t}\n\t\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "078c75d5164b2b059aa88af3a10c3037bfe3349724377deff793a2bd4cc2a04e",
            "glog-pfp-ruleFileCode/v1": "6cb0630bf849ab113c588d225bea2b0994d46f3b25ff2add9340df85ff11df50"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "6cb0630bf849ab113c588d225bea2b0994d46f3b25ff2add9340df85ff11df50"
          },
          "properties": {}
        },
        {
          "ruleId": "e3cfc2e2-c151-3215-951e-1e63bf9d4460",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Insecure Hashing Methods Detected: MD5, SHA1 Inadequate for Security, bcrypt/scrypt/Argon2 and SHA-256+ Recommended."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/authHandler.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 28,
                  "endLine": 78,
                  "endColumn": 47,
                  "snippet": {
                    "text": "\t\t\t\t\tif (req.body.token == md5(req.body.login)) {"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "fc7b26ea5dcb664e084aea4148e3fd5a73ff93c702506fff340ef87cc115cb23",
            "glog-pfp-ruleFileCode/v1": "a14b67d3a3a408e6360ff9c3f367eb7fdd2289efb610c180caede437eb7aaf91"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "a14b67d3a3a408e6360ff9c3f367eb7fdd2289efb610c180caede437eb7aaf91"
          },
          "properties": {}
        },
        {
          "ruleId": "9225247f-64c7-3daa-84ac-d02dd219a622",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/passport.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 13,
                  "startColumn": 9,
                  "endLine": 24,
                  "endColumn": 11,
                  "snippet": {
                    "text": "        db.User.findOne({\n            where: {\n                'id': uid\n            }\n        }).then(function (user) {\n            if (user) {\n                done(null, user);\n            } else {\n                done(null, false)\n            }\n\n        })"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "7cf4a583e84a3efbd379bc6b709268c17310300596564082da19b165c86bd399",
            "glog-pfp-ruleFileCode/v1": "2728e751ad73d87f91181ee1b27e39a08e04ff72bbfd1c97ca2463de4845fa22"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "2728e751ad73d87f91181ee1b27e39a08e04ff72bbfd1c97ca2463de4845fa22"
          },
          "properties": {}
        },
        {
          "ruleId": "866313ba-f531-3b3a-acc7-36dbe347579d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/passport.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 31,
                  "startColumn": 13,
                  "endLine": 43,
                  "endColumn": 15,
                  "snippet": {
                    "text": "            db.User.findOne({\n                where: {\n                    'login': username\n                }\n            }).then(function (user) {\n                if (!user) {\n                    return done(null, false, req.flash('danger', 'Invalid Credentials'))\n                }\n                if (!isValidPassword(user, password)) {\n                    return done(null, false, req.flash('danger', 'Invalid Credentials'))\n                }\n                return done(null, user);\n            });"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "4a064aab7985d69f833a3bad32e45100358c930bb529d75b902ba41418c9e4a0",
            "glog-pfp-ruleFileCode/v1": "36cba2615d5ac08e075d449374cad34c78d4b753fedf82819b4d552531712eb0"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "36cba2615d5ac08e075d449374cad34c78d4b753fedf82819b4d552531712eb0"
          },
          "properties": {}
        },
        {
          "ruleId": "224b9ad3-a232-35a6-88cf-2bbd5fc79af5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "core/passport.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 33,
                  "endLine": 72,
                  "endColumn": 35,
                  "snippet": {
                    "text": "                                db.User.create({\n                                    email: req.body.email,\n                                    password: createHash(password),\n                                    name: req.body.name,\n                                    login: username\n                                }).then(function (user) {\n                                    return done(null, user)\n                                })"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "e75dc20192c117491ca2e74228b4f4cdc4f7a5b219de5404e560d6f05416ae41",
            "glog-pfp-ruleFileCode/v1": "066130ca2801cfb43bd549ac043aa0c81cb0a4cd3beeb935b56c76e9d30fc3f1"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "066130ca2801cfb43bd549ac043aa0c81cb0a4cd3beeb935b56c76e9d30fc3f1"
          },
          "properties": {}
        },
        {
          "ruleId": "f40d37bc-a799-33d2-976e-505fb388e17a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Unhandled Promise Rejection Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "models/index.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 18,
                  "startColumn": 1,
                  "endLine": 22,
                  "endColumn": 5,
                  "snippet": {
                    "text": "sequelize\n  .authenticate()\n  .then(function (err) {\n    console.log('Connection has been established successfully.');\n  })"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "02aefa470daaa1d7e4a675e9cf037d166824286667fe96ef13cb43f6de773d22",
            "glog-pfp-ruleFileCode/v1": "9dc09d1108f53b7c3478afa37b8468aafcb46cb50f6fe924eadb2ce0fd65eedf"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "9dc09d1108f53b7c3478afa37b8468aafcb46cb50f6fe924eadb2ce0fd65eedf"
          },
          "properties": {}
        },
        {
          "ruleId": "073f2b99-5b1e-39a8-8ef2-1116fdbbfb79",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential Out-of-Destination Writing Vulnerability\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "models/index.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 34,
                  "endLine": 43,
                  "endColumn": 60,
                  "snippet": {
                    "text": "    var model = sequelize.import(path.join(__dirname, file));"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "179daf6e0f06b30622a34e86ea18eb4646c14c13358bca4a6f753911aacb644c",
            "glog-pfp-ruleFileCode/v1": "91b238fda8649fde2c58a7a732138da7a9a42f28d0fa6086fbedaf4053bb0904"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "91b238fda8649fde2c58a7a732138da7a9a42f28d0fa6086fbedaf4053bb0904"
          },
          "properties": {}
        },
        {
          "ruleId": "2992bbde-9c2e-361f-91b2-31865be4434c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Potential XSS Vulnerability from User-Controlled Data in HTML String\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "routes/main.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 3,
                  "endLine": 29,
                  "endColumn": 5,
                  "snippet": {
                    "text": "\t\tres.render('vulnerabilities/layout', {\n\t\t\tvuln: req.params.vuln,\n\t\t\tvuln_title: vulnDict[req.params.vuln],\n\t\t\tvuln_scenario: req.params.vuln + '/scenario',\n\t\t\tvuln_description: req.params.vuln + '/description',\n\t\t\tvuln_reference: req.params.vuln + '/reference',\n\t\t\tvulnerabilities:vulnDict\n\t\t}, function (err, html) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(err)\n\t\t\t\tres.status(404).send('404')\n\t\t\t} else {\n\t\t\t\tres.send(html)\n\t\t\t}\n\t\t})"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "fa24c3e3ac8bdbf6f30ee25dccfb940d41533d143872a354fcd37156e2a9fa43",
            "glog-pfp-ruleFileCode/v1": "ee71c376aff21ac374d692dada9caf9426f950d53572a4c884b9d55f7e5f75cd"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ee71c376aff21ac374d692dada9caf9426f950d53572a4c884b9d55f7e5f75cd"
          },
          "properties": {}
        },
        {
          "ruleId": "9dd77efa-9225-3872-a5ca-87b17ddcb5cd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Direct Writing to Response Object May Lead to XSS Vulnerability"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "routes/main.js",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 27,
                  "startColumn": 5,
                  "endLine": 27,
                  "endColumn": 19,
                  "snippet": {
                    "text": "\t\t\t\tres.send(html)"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "6fbc57301235501f775fcabe1e168a32ec8faa20b2c27945a9de8280012bfb80",
            "glog-pfp-ruleFileCode/v1": "7f0f028e32eaf21d4080d350b1fc7f637e30f78ef12b5b02d4d518b187f4fa28"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "7f0f028e32eaf21d4080d350b1fc7f637e30f78ef12b5b02d4d518b187f4fa28"
          },
          "properties": {}
        },
        {
          "ruleId": "b645aa4b-e8e1-33be-9761-d900b708a3ca",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"EJS Output Unescaped Vulnerability Allowing XSS Attacks\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/vulnerabilities/layout.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 35,
                  "startColumn": 13,
                  "endLine": 35,
                  "endColumn": 40,
                  "snippet": {
                    "text": "            <%- include(vuln_scenario) %>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "91738070d4debc36a54617507a2c6d403a8e4a5cced26705b9edfcb6b54da014",
            "glog-pfp-ruleFileCode/v1": "21eee536736781931e0b192de852ef1c27c2c3f863be7ed141973eccc2156a89"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "21eee536736781931e0b192de852ef1c27c2c3f863be7ed141973eccc2156a89"
          },
          "properties": {}
        },
        {
          "ruleId": "e9e21afb-68e3-3247-ab33-4e782da01bc9",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"EJS Output Unescaped Vulnerability Allowing XSS Attacks\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/vulnerabilities/layout.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 38,
                  "startColumn": 13,
                  "endLine": 38,
                  "endColumn": 43,
                  "snippet": {
                    "text": "            <%- include(vuln_description) %>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "5524d045849950e9dd042ab36f7ab7727357e379955a332002a81ff0d51df3ef",
            "glog-pfp-ruleFileCode/v1": "ccb3d7b105b26dc2e3ba5d29f931e725ae0c1c5cb22f5101b1bf495a86e46056"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "ccb3d7b105b26dc2e3ba5d29f931e725ae0c1c5cb22f5101b1bf495a86e46056"
          },
          "properties": {}
        },
        {
          "ruleId": "55c7a894-c974-3bc7-94b0-70273d620d6e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"EJS Output Unescaped Vulnerability Allowing XSS Attacks\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "views/vulnerabilities/layout.ejs",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 13,
                  "endLine": 41,
                  "endColumn": 41,
                  "snippet": {
                    "text": "            <%- include(vuln_reference) %>"
                  }
                }
              }
            }
          ],
          "partialFingerprints": {
            "glog-pfp-ruleFileLineCode/v1": "64d1b32612a3246fc802e592395145256c2533ba564cedee6a315cb28ea05af9",
            "glog-pfp-ruleFileCode/v1": "380cea43e4f520d801b0a71773921e2f9a4f22e2bde6e967c84665d5ae23dfe9"
          },
          "fingerprints": {
            "glog-fp-ruleFileCode/v1": "380cea43e4f520d801b0a71773921e2f9a4f22e2bde6e967c84665d5ae23dfe9"
          },
          "properties": {}
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}